<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>Qiuliang's Site</title>
   <link href="http://qiuliang.github.io/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://qiuliang.github.io" rel="alternate" type="text/html" />
   <updated>2016-09-15T11:02:06+08:00</updated>
   <id>http://qiuliang.github.io</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>Java内存模型解析</title>
     <link href="http://qiuliang.github.io/tech/2016/09/14/jvm-ram-module.html"/>
     <updated>2016-09-14T00:00:00+08:00</updated>
     <id>http://qiuliang.github.io/tech/2016/09/14/jvm-ram-module</id>
     <content type="html">&lt;blockquote&gt;
  &lt;p&gt;基于HotSpot虚拟机&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;运行时数据区域&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;线程私有&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;程序计数器：相当于当前线程所执行字节码的行号指示器&lt;/li&gt;
  &lt;li&gt;java虚拟机栈：局部变量表部分，存放编译期可知的各种基本数据类型，其中64位的long和double占用2个Slot，其他占用1个Slot&lt;/li&gt;
  &lt;li&gt;本地方法栈：类似于java虚拟机栈，但本地方法栈为本地native方法服务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;线程共享&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;java堆，被所有线程共享，在虚拟机启动时创建&lt;/li&gt;
  &lt;li&gt;方法区，用于存放类信息、常量、静态变量，属于虚拟机的一个逻辑部分，但有个别名叫非堆（Non-Heap）&lt;/li&gt;
  &lt;li&gt;直接内存，NIO可以使用Native函数直接分配堆外内存&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/blog/2016/jvm-ram-module.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Sun HotSpot虚拟机使用永久代来实现方法区，因永久代有 -XX:MaxPermSize的上限， jdk 1.7以后，已经把原本放在方法区（永久代）中的字符串常量池移出&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;关于String.intern方法在JDK1.6和1.7中使用方法区内存方面的差异&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;String.intern是一个Native方法，如果字符串常量池中已包含一个等于此String对象的字符串，则返回常量池中代表这个字符串的String对象，否则，将此String对象包含的字符串添加到常量池中，并且返回String对象的引用。&lt;/p&gt;

&lt;p&gt;在JDK1.6中，intern()方法会把首次遇到的字符串实例复制到永久代中，而JDK1.7中不再复制实例，只是在常量池中记录首次出现的实例引用，对内存占用有较大减少。&lt;/p&gt;

&lt;p&gt;垃圾收集主要针对java堆，基本都采用分代收集算法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;新生代&lt;/li&gt;
  &lt;li&gt;老年代&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;还可以细分为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Eden空间&lt;/li&gt;
  &lt;li&gt;From Survivor空间&lt;/li&gt;
  &lt;li&gt;To Survivor空间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），
主流虚拟机在分配java堆内存空间时，都可以进行扩展，通过 -Xmx 和 -Xms控制，如果空间不够时，则抛出OutOfMemoryError。&lt;/p&gt;

&lt;h2 id=&quot;java&quot;&gt;Java堆中对象分配、布局和访问&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;对象分配&lt;/h3&gt;

&lt;p&gt;从虚拟机的视角来看new一个java对象的过程：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;检查类对象是否在常量池中存在这个类对象的符号引用&lt;/li&gt;
  &lt;li&gt;如果这个符号引用代表的类还没有加载、解析和初始化过，需要先执行相应的类加载过程&lt;/li&gt;
  &lt;li&gt;为对象分配内存，两种方式：指针碰撞（Serial、ParNew等带Compact过程的收集器）、空闲列表（CMS这种基于Mark-Sweep算法的收集器）&lt;/li&gt;
  &lt;li&gt;对对象进行必要的设置，包括是哪个类的实例、对象的哈希值、GC分代年龄，这些信息存放在对象头（Object Head）中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;内存分配并发问题的两种解决方案：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对分配内存的动作进行同步处理，保证更新操作的原子性&lt;/li&gt;
  &lt;li&gt;按照线程划分不同的空间进行，TLAB，只有TLAB空间用完时，才需要同步锁定，可通过参数：-XX:+/-UseTLAB&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;对象内存布局&lt;/h3&gt;

&lt;p&gt;分三块区域：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对象头（Header）&lt;/li&gt;
  &lt;li&gt;实例数据（Instance Data）&lt;/li&gt;
  &lt;li&gt;对齐填充（Padding）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对象头存储两部分数据，第一部分是对象自身的运行时数据，例如：哈希值、GC分代年龄、锁状态标志、线程持有的锁等。另一部分是类型指针，虚拟机通过这个指针来确定属于哪个类的实例。
实例数据存储程序代码中定义的各种字段内容。
对齐填充区域用于补全对象的起始地址是8字节的整数倍。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;对象访问&lt;/h3&gt;

&lt;p&gt;java程序通过栈上的引用指针来操作堆上的具体对象，具体如何访问取决于虚拟机的实现方式，主流有两种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用句柄&lt;/li&gt;
  &lt;li&gt;直接指针&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两种方式各有优劣，简单来说，句柄方式在reference中存储的是稳定的句柄地址，但需要两次寻址以获得对象实例数据和类型数据。直接指针节省了一次指针定位的时间开销。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Sun HotSpot使用直接指针来访问数据。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-4&quot;&gt;内存分配相关异常&lt;/h2&gt;

&lt;h3 id=&quot;javaoutofmemoryerror&quot;&gt;Java堆内存问题：OutOfMemoryError&lt;/h3&gt;

&lt;p&gt;如果出现了OutOfMemoryError的异常，需要确定是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;内存泄漏的意思是说GC无法对对象进行自动回收，如果是溢出，就是说内存中的对象还必须存活但空间不够了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;内存泄漏需要检查对象是通过怎样的路径和GC Roots相关联，内存溢出一般需要检查虚拟机堆参数：-Xms/-Xmx和物理内存的关系，以及从代码层面检查某些对象的生命周期。&lt;/p&gt;

&lt;h3 id=&quot;stackoverflowerroroutofmemoryerror&quot;&gt;虚拟机栈内存问题：StackOverflowError和OutOfMemoryError&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError&lt;/li&gt;
  &lt;li&gt;如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;栈容量由-Xss参数设定，-Xoss设置本地方法栈大小在HotSpot虚拟机中无效&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;虚拟机可用栈内存容量计算公式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;进程最大内存容量 - 最大堆容量（Xmx）- 最大方法区容量（MaxPermSize）= 虚拟机栈内存总容量&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;根据以上公式，如果每个线程所分配的栈容量越大，则可建立的线程数量就会减少。在开发多线程应用时，如果出现内存溢出，在不能减少线程数或者增加物理内存的情况下，可以考虑减少最大堆和栈容量来换取更多的线程数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-5&quot;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html&quot;&gt;Sun HotSpot VM启动参数详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
   </entry>
   
   <entry>
     <title>基于GitLab API实现自动化任务</title>
     <link href="http://qiuliang.github.io/tech/2016/05/31/invoke-gitlab-api.html"/>
     <updated>2016-05-31T00:00:00+08:00</updated>
     <id>http://qiuliang.github.io/tech/2016/05/31/invoke-gitlab-api</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;之前在团队里&lt;a href=&quot;/tech/2015/10/02/git-nexus-jenkins-ci.html&quot;&gt;基于git、maven、nexus、jenkins搭建适合中小型技术团队的CI平台&lt;/a&gt;，这套系统运行近一年，整体来说还是比较稳定可靠，使用起来也比较方便，基本解决了中小规模团队的CI需求。&lt;/p&gt;

&lt;p&gt;但有个功能一直未完善，使用起来略有不便，就是自动打tag，因我们的build和部署是采用了两套jenkins去实现，而在部署环节的jenkins，是不需要和git交互的，因此也不方便使用类似：&lt;code&gt;git tag&lt;/code&gt; 这样的命令去完成自动打tag的功能。&lt;/p&gt;

&lt;p&gt;因此首先想到的解决方案便是在部署机上通过插件或CURL等方式去调用gitlab的一个api，这样应该能够解决这个问题。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;实现&lt;/h2&gt;

&lt;p&gt;研究了下gitlab的官方文档，发现确实有提供相关API来进行tag的创建，除此之外，还提供了很多其他API，足够你实现很多方便的功能。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;授权&lt;/h3&gt;

&lt;p&gt;调用api都需要使用一个gitlab账号的private token，每个git账号都有不同的private token，查看方法：
登录gitlab，进入Profile Setting — Account，可以看到如下界面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/blog/2016/gitlab-token.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个token可以通过header或者query string方式加到调用请求里。&lt;/p&gt;

&lt;h3 id=&quot;api&quot;&gt;调用API&lt;/h3&gt;

&lt;p&gt;以创建tag为例，其api形式如下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;POST /projects/:id/repository/tags&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;其中参数id可以通过另一接口获取：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;GET /projects&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;传入必须的参数后，gitlab会返回类似于如下的消息，则说明创建tag成功：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;s2&quot;&gt;&amp;quot;name&amp;quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&amp;quot;test&amp;quot;&lt;/span&gt;,
  &lt;span class=&quot;s2&quot;&gt;&amp;quot;message&amp;quot;&lt;/span&gt;: null,
  &lt;span class=&quot;s2&quot;&gt;&amp;quot;commit&amp;quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;id&amp;quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&amp;quot;7cdbfcf12de62dae7fef5ad7eac6b41ab6d04ad9&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;message&amp;quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&amp;quot;Merge branch &amp;#39;weixin&amp;#39; into develop\n&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;parent_ids&amp;quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;s2&quot;&gt;&amp;quot;82e05eb5e681f46810b6e113140bc8577ee0ec64&amp;quot;&lt;/span&gt;,
      &lt;span class=&quot;s2&quot;&gt;&amp;quot;bb2c9646608196eaf4fb5b9b39b5f74bfd9df9b1&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;,
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;authored_date&amp;quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&amp;quot;2016-05-30T18:06:53.000+08:00&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;author_name&amp;quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&amp;quot;test&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;author_email&amp;quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&amp;quot;qiuliang@sohochina.com&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;committed_date&amp;quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&amp;quot;2016-05-30T18:06:53.000+08:00&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;committer_name&amp;quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&amp;quot;test&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;committer_email&amp;quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&amp;quot;qiuliang@sohochina.com&amp;quot;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,
  &lt;span class=&quot;s2&quot;&gt;&amp;quot;release&amp;quot;&lt;/span&gt;: null
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;api-1&quot;&gt;部署成功后调用api&lt;/h3&gt;

&lt;p&gt;直接基于jenkins提供的后置脚本功能即可，首先增加全局环境变量配置：GIT_API_TOKEN，其余参数可以为每个project进行配置。&lt;/p&gt;

&lt;p&gt;shell代码如下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;curl -X POST &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
--header &lt;span class=&quot;s2&quot;&gt;&amp;quot;PRIVATE-TOKEN: $GIT_API_TOKEN&amp;quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
--data &lt;span class=&quot;s2&quot;&gt;&amp;quot;tag_name=$Version&amp;amp;ref=$Tag_Ref&amp;amp;release_description=$Tag_Desc&amp;quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
http://code.gitlab.com/api/v3/projects/1/repository/tags&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;完成以上配置，在每次部署成功后都会调用gitlab的api自动创建tag。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>如何对gitlab server进行备份和恢复</title>
     <link href="http://qiuliang.github.io/tech/2016/03/09/gitlab-backup.html"/>
     <updated>2016-03-09T00:00:00+08:00</updated>
     <id>http://qiuliang.github.io/tech/2016/03/09/gitlab-backup</id>
     <content type="html">&lt;blockquote&gt;
  &lt;p&gt;基于gitlab社区版8.5.4&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;创建一个备份&lt;/h2&gt;
&lt;p&gt;gitlab为我们提供了一些方法来创建一个完整的备份，该备份文件是一个压缩包，名称类似于：&lt;code&gt;[Timestamp]_gitlab_backup.tar&lt;/code&gt; 该备份文件包含了所有的DB数据、仓库文件、以及用户上传的一些附件。&lt;/p&gt;

&lt;p&gt;进行一次备份：
sudo gitlab-rake gitlab:backup:create&lt;/p&gt;

&lt;p&gt;最终如果出现如下提示信息，则代表备份成功。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/blog/gitlab-backup.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;备份文件默认保存在如下目录：/var/opt/gitlab/backups，可通过编辑 /var/opt/gitlab/gitlab-rails/etc/gitlab.yml文件的Backup Settings节进行修改。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;备份配置文件&lt;/h3&gt;

&lt;p&gt;db的授权文件和两步验证所需要的密钥信息存储在/etc/gitlab/gitlab-secrets.json文件中，需要单独备份。
gitlab.yml文件也不会包含在上面的备份文件中。&lt;/p&gt;

&lt;h2 id=&quot;gitlab&quot;&gt;恢复gitlab&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;按照官方文档的要求，只能还原备份文件到同一版本的gitlab系统中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;先搭建一个同版本的gitlab到另外一台主机上。（具体安装步骤请参考官方文档）&lt;/p&gt;

&lt;p&gt;环境准备完成后，执行如下命令：
1，拷贝备份文件到新的主机上。
2，停止相关服务
sudo gitlab-ctl stop unicorn
sudo gitlab-ctl stop sidekiq
3，还原数据
gitlab-rake gitlab:backup:restore BACKUP=1457505197
4，启动
sudo gitlab-ctl start&lt;/p&gt;

&lt;p&gt;做完上述操作后，查看系统数据都已经恢复，包括仓库、用户、分组等。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;配置文件和secret文件的恢复需要手工操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-2&quot;&gt;其他实践&lt;/h2&gt;

&lt;h3 id=&quot;git-data&quot;&gt;更改git data目录&lt;/h3&gt;

&lt;p&gt;为了保证数据的安全，一般我们会考虑把git的数据目录放到其他共享存储中，比如：NAS、Virtual SAN等，这时就需要我们修改gitlab中默认的data文件存储路径。&lt;/p&gt;

&lt;p&gt;1，修改gitlab.rb文件中的 git-data-dir参数
2，gitlab-ctl reconfigure
3，gitlab-ctl start&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;自动备份&lt;/h3&gt;

&lt;p&gt;gitlab已经为我们提供了自动备份数据的解决方案，包括cron任务的管理、自动同步到第三方云存储（例如亚马逊AWS），具体参考：http://doc.gitlab.com/ce/raketasks/README.html
当然你也可以用其他方式来备份数据，例如我们的git server位于虚拟化环境，那么可以定期完全备份整个虚机和磁盘，恢复起来也很简单的方便。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>罗辑思维观点解读（一）</title>
     <link href="http://qiuliang.github.io/life/2016/03/02/logic-mind-1.html"/>
     <updated>2016-03-02T00:00:00+08:00</updated>
     <id>http://qiuliang.github.io/life/2016/03/02/logic-mind-1</id>
     <content type="html">&lt;p&gt;&lt;img src=&quot;/images/blog/yinhexi.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以下文字皆源于上班路上听到的罗辑思维节目，节选了一些个人认为对自己有一些启发的观点或知识，整理和思考后分享出来。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;关于末日和对生命的态度&lt;/h2&gt;

&lt;p&gt;世界是否真的存在末日？这个问题相信没有谁能从技术角度回答。但罗辑思维这期主要想要表达的是一种对生命的态度。
生命必然会走向一个终点，可很多现代人似乎忘记了这一点，在有限的生命里，去浪费大把的时光，甚至对生命不再持敬畏之心，如行尸走肉一般。
人之将死，其言也善。这在很多历史人物上得到了印证，可见在“末日”真的到来时，人心终将回归最为纯净的一面，不管之前做了多大的恶。与其这样，不如怀着一颗向死而生的心，认真生活，让生命更有意义和丰富多彩。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;见识决定命运？拒绝逃离北上广&lt;/h2&gt;

&lt;p&gt;所谓见识，只是一个通俗易懂的说法，在现代这个信息爆炸的年代，通过互联网你几乎能了解到人类所有的信息，不管是科技还是经济、政治，这似乎说明，不一定要生活在大城市，你才能拥有“见识”，通过其他渠道你还是能获得这些信息。
但“1/8秒延迟理论”却说明，直接的、面对面的连接，效果一定好于通过电波的连接，只有在这些大量的真实连接的场景下，你才会有更多的机会。
大城市因为各种各样的原因，成为人口最容易聚集的地方，而人口的聚集效应又为创造财富提供好的环境和大量的机会。
因此基于以上简单但有力的结论，推断出至少在未来几十年时间里，一线城市规模还会不断放大，甚至达到上亿级别的超级城市。或许等到人类科技和文明进化到一个更高的台阶的时候，我们才能去过上那种田园诗歌的生活。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;中国未来经济走势&lt;/h2&gt;
&lt;p&gt;这个话题太大，以个人现在的眼界见识，不足以做出一些有价值的总结，但效仿和学习却是可以的。简单来说，前三十年的我们难以想象现在的情景，未来三十年似乎没有理由不变得更好，我们已经走完了基本物质需求经济的时代，新的经济板块需要时代的前瞻者创造出来，这将有着无限多的机会，我们需要时刻准备着。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;互联网时代的隐私&lt;/h2&gt;
&lt;p&gt;关于这个话题，个人在前段时间也有过一些思考并且得出的结论是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在当下的互联网时代，基本没有隐私可言，除非你做一个与世隔绝的隐士。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当然这个没有隐私是相对的，并不是说你的邻居、同事或周围的陌生人对你的一切了如指掌，而是指我们的隐私对于大的互联网公司、银行、国家机构等来说的，他们要获取你的信息非常容易，电商购物记录、家庭/公司地址、朋友圈、银行/保险账户、航空/铁路售票记录、酒店check in记录、遍布各地的摄像头。。，实在是太多了，通过一个身份证号或手机号，就能很容易的勾勒出一个人的大致画像，包括你的年龄、性别、姓名、家庭成员、公司、收入情况等等，想想是不是很可怕？&lt;/p&gt;

&lt;p&gt;其实不然，这恰恰是社会文明进步的一种必然结果，所有的这些其实都是一个人的信用记录，一个人如果打算去做一件违法或者违反道德的事情，就不得不仔细掂量掂量，自己有没有这个能力能把所有的一切都能处理的干干净净？有了不良信用记录之后，他以后还想不想混了，只要他还不打算和社会失去连接，那就不得不去接受这个大信用体系框架带来的惩罚。而这个后果往往是很严重的，虽然现在国内的社会信用评价体系还处在起步阶段，不够健全和完善，但随着时间的推移，终将会成为现实，所以当下我们的生活法则也许要变成：&lt;strong&gt;事无不可对人言&lt;/strong&gt;。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>工作十年回顾：成长与平衡</title>
     <link href="http://qiuliang.github.io/life/2016/01/23/2015_summary.html"/>
     <updated>2016-01-23T00:00:00+08:00</updated>
     <id>http://qiuliang.github.io/life/2016/01/23/2015_summary</id>
     <content type="html">&lt;p&gt;&lt;img src=&quot;/images/blog/xingkong.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;时间总是在我们毫不知情的情况下偷偷溜掉，不禁黯然神伤，在年末的时候能沉下心来花点时间梳理、思考，并能给自己这一年通过文字留下点什么，或许是件然并卵的事情，但起码会得到一点点心理的慰藉，这就够了。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;2015一些重要的数字&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;看完和正在看的书：9本（数字参考于豆瓣我读）&lt;/li&gt;
  &lt;li&gt;发表的博文：5（个人博客）&lt;/li&gt;
  &lt;li&gt;跑步公里数：53Km/11次（咕咚运动）&lt;/li&gt;
  &lt;li&gt;陪伴孩子：基本每个周末都会陪伴&lt;/li&gt;
  &lt;li&gt;陪伴父母：1次&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一年过完，在这些不能带来经济价值，却又很重要的事情上，究竟花了多少时间。
显然除了陪孩子以外，其他数字少得可怜，先留在这里，等未来的某一天看到，并能起到如我所期望那样的一些作用。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;工作10年回顾&lt;/h2&gt;

&lt;p&gt;这是一个有点伤感，又有点让人自豪的事情，工作已10年光景，人生中最热血、宝贵的青春投入到了一个叫“工作”的伟大事业中去，可工作究竟是什么，为什么要工作？在这样的一个阶段，我想停下来仔细思考一番，并以下面的几个问题来回顾总结一下我的第一个十年。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;工作的终极目的是什么？&lt;/h3&gt;

&lt;p&gt;对绝大部分普通人来说，工作和上班其实是画等号的，工作的意义也很简单，通俗一点就是养家糊口。于我而言，前十年的工作也基本是这样一种状态，每天上下班，每月领工资，在工作上的投入程度也跟收获基本成正比，因为有一份工作，让我在亲朋好友眼中看起来是一个正常的人，结婚、生子、买房等等，所有这些“工作”都功不可没，看起来似乎还不错，是吗？&lt;/p&gt;

&lt;p&gt;前几天看了一些有关远程工作社区的分享，感触颇深，其中一个重要的观点就是：上班 ≠ 工作。深以为是，上班其实是一种被动的状态，多少有些无奈的感觉在里面，而工作更多的是一种积极的状态，工作代表着专业、专注，工作的时候你会全情投入，而上班却未必。看似矛盾，却又高度统一，当我感觉自己是在上班的时候，就会去想每天这么做的目的究竟是什么？如果感觉是在工作呢，就会心无旁骛，当完成目标的时候心里盛满了幸福感和满足感。这样的状态是最理想的状态，可人终归有七情六欲、喜怒哀乐，不会总是处于最理想的状态，少量的“上班”而不是“工作”也无可厚非，只是你自己要承担这样的后果罢了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;作为某个社会分工领域专业的人，达成目标，并由此带来内心的愉悦和物质上的收获。这是我在2015年的答案，将来或许会有新的思考。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-3&quot;&gt;如何平衡工作和生活？&lt;/h3&gt;

&lt;p&gt;除了工作，剩下的就是你的生活。你是一个什么样的人，你的生活就是什么样的。但工作却不一定，或多或少都会去扮演职场上的自己。在不同的角色之间切换，保持自律和规律的生活是一个比较有效的平衡方式。周一到周五，固定的时间起床、吃饭、上班、睡觉，周末相对自由随性一些。这样的好处就是当你面对每天的工作时，不会因为一些其他事情而影响到你，工作效率和质量始终是稳定的，周末放松一下，陪陪孩子家人，工作暂时放在一边，也能得到比较好的休息。&lt;/p&gt;

&lt;p&gt;坏处就是平时的生活会变得单调和匆忙，而空闲的时间如果没有用来做一些提升自己的事情，也会有一些失落和焦虑感。解决这些问题的方法自然也是有的，很认同去年朋友圈里转发比较多的一篇文章，大意是生活需要一些&lt;strong&gt;仪式感&lt;/strong&gt;，每个人都应该保持一些认真、庄重的生活态度。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我向来觉得生活是需要一些仪式感的，这跟矫情无关，而是关于你对生活的热爱，对幸福的敏感，乃至有时候它是一种结束，也是一种开始。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个人也要认真的吃饭喝茶，遇到节日纪念日，更是要花点心思庆祝一番，这是我们对生活的一种热爱，在我们每天单调和匆忙的工作中，加入一些生活的情趣和仪式感，就好像我们在吃面条的时候，加一点喜爱的辣酱，回味无穷。&lt;/p&gt;

&lt;p&gt;每个生活在大都市的普通人，都会有一些焦虑感，时时刻刻都在想着挑战自己，做更好的、更成功的自己，可社会就是这样，成功者只是少数，大多数人都如同你我一样平凡，我们成不了马云、马化腾，也成不了罗永浩、罗玉凤，那就还是降低自己的要求和欲望，做一个普通人或是旁观者，也没什么不好。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;慢生活（英语：Downshifting），又称 慢活，是一种社会行为或趋势，其倡导人们摆脱对物质疯狂的迷恋，重过简单的生活，并减少“压力，加班，和可能伴随着它的心理代价”[1]。它强调在日常生活中寻找工作与生活的平衡[2]，并专注于个人价值的实现，和建立人际关系的人生目标，而不是纯粹为了消费而追求经济成功。 –维基百科&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-4&quot;&gt;需要成长为一个什么样的技术人？&lt;/h3&gt;

&lt;p&gt;从事技术工作（软件开发领域）这么长的时间，很庆幸自己还保持着对技术、科技的热情，相信很多同行朋友也是一样的感觉，但技术的发展却又是日新月异，这对我们的学习能力形成巨大的挑战，以下我总结了一些学习新技术的方法或是思考：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一门新语言远没有你想象的困难，一天或是一周也许就够了&lt;/li&gt;
  &lt;li&gt;技术生态圈很重要，学会语言不代表你了解相关生态圈&lt;/li&gt;
  &lt;li&gt;官网文档是最权威的资料，需要最先看&lt;/li&gt;
  &lt;li&gt;github作为全球最大同性（chengxuyuan）交友社区，自然不容错过&lt;/li&gt;
  &lt;li&gt;不要给自己设限，写java的也可以写python，写go的也可以写js，工程师也可以懂产品和体验，相信人的潜力无穷&lt;/li&gt;
  &lt;li&gt;不可替代性是职场重要法则，无关技术，却又依托技术&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然还有很多有益的经验教条，就不一一复述，这个话题如果展开，估计可以写成几个系列，先给自己埋个坑以后再填。&lt;/p&gt;

&lt;p&gt;那究竟要成长为一个什么样的技术人？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在某几个领域有扎实的基本功&lt;/li&gt;
  &lt;li&gt;保持对技术的热情，具备随时挽起袖子上战场的能力和魄力&lt;/li&gt;
  &lt;li&gt;定期的算法/数据结构训练，保持这方面的感觉&lt;/li&gt;
  &lt;li&gt;T字形知识结构&lt;/li&gt;
  &lt;li&gt;除了技术，要关注产品、经济和文化&lt;/li&gt;
  &lt;li&gt;正确的引导新人，乐意看到新人快速成长&lt;/li&gt;
  &lt;li&gt;在团队里具备技术影响力&lt;/li&gt;
  &lt;li&gt;训练你的沟通能力，再进化到现场演讲能力&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虽然自己认识到这么多，可还远没达到这个层次，除了修炼，无他。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这十年我对工作的认知，肤浅也好深刻也罢，都只是自我的一些思考。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-5&quot;&gt;阅读&lt;/h2&gt;

&lt;p&gt;传统意义上的阅读，我还是更偏爱纸质书，即使在现在电子媒体如此发达的今天，2015年看的书不多，寥寥几本，印象比较深刻的如《从0到1》、《万万没想到》、《文明之光》，领域涵盖创业、思维和人文历史，也是个人比较感兴趣的几个方面。&lt;/p&gt;

&lt;p&gt;《万万没想到》算是一本比较另类的书，作者以一个科学家的严谨，用了大量的数据和实验来说明，很多我们习以为常的事情、常识，往往都是错误的，在面对任何一件事情或现象的时候，不要用所谓的常识和固有的经验来禁锢你的思想，也许你是对的，谁又知道呢？&lt;/p&gt;

&lt;p&gt;在下半年的时候为了解决开车途中的无聊，开始大量的听两档脱口秀节目，《晓松奇谈》和《逻辑思维》，虽然都是靠听的，但我认为这也属于阅读的一种，毕竟上下班路上将近3小时的时间里，是可以听很多东西的，这两档节目的内容个人认为还是有一些干货和深度，对我们还是有一些帮助。&lt;/p&gt;

&lt;p&gt;正如逻辑思维2015跨年演讲中提到的，在这个信息大爆炸的时代，看似欣欣向荣、繁花似锦的互联网媒体、自媒体，真正能带给我们有价值的东西，或者说接近于这个世界真相的东西，却是少之又少，或者说是信息噪音干扰太大，我们迷失在一个多维的信息空间，却找不到通往外部的出口。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;通过阅读优质的书本和文章，是我们了解这个复杂世界最重要的方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-6&quot;&gt;停用微信朋友圈的思考&lt;/h2&gt;

&lt;p&gt;从十月底到现在为止，停刷微信朋友圈近三个月，除了确实因为太忙这个理由，我也想试试，生活会有什么变化。
其实是没什么变化。&lt;/p&gt;

&lt;p&gt;失去了什么？&lt;/p&gt;

&lt;p&gt;最近这一个月里，我错过了各位亲朋好友、同学同事、邻居、朋友的朋友、熟悉或不熟悉的人，你们的每一次分享，每一个动态。让人羡慕的旅行、萌宝、美食、美颜照。还错过了各种鸡汤、好笑或不好笑的段子、新闻、谣言、行业干货湿货。丰富多彩、五花八门，有如这冬日里的鸳鸯火锅。然而这些并没有什么用，有价值的信息很少能从朋友圈获取到，但少了跟好友们的互动，还是觉得缺了点什么。&lt;/p&gt;

&lt;p&gt;有失必有得，停刷朋友圈（不是完全不看，是可以集中某个时间段快速、整体的去看）带来的好处也是显而易见的，不会占用我们的一些碎片时间，工作和生活会更加专注，对于一些真正的朋友，面对面或一对一的交流似乎是更有效和更能巩固关系的方式。对于真正想联系的朋友，少点几个赞完全不会影响我们的关系，不是吗？我们自然会通过见面、微信QQ、电话这些方式来建立彼此的联系，这种方式不是更好么。&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;继续前行&lt;/h2&gt;

&lt;p&gt;2016年已经开始，太多的展望并没有什么作用，坚持和踏实依然是我目前认为最简单有效的生活态度和工作方式，做好当下的自己，确保在写完这篇3000多字的总结后，在马上要进入到35岁这个以前觉得很遥远年纪的时候；在面对未来人类进入到更高效科技更发达的时候；在少数精英洞悉这个社会商业法则而大多数人还懵懵懂懂的时候，活得更明白、更滋润一些。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;题图&lt;/h3&gt;

&lt;p&gt;《星夜》文森特.梵高于1889年作于法国。色彩斑斓的颜色对比，流泻、粗狂的画作手法，产生了强烈的星空流动的感觉，展现出非凡的生命力。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>【jenkins实战】利用shell实现远程重启tomcat</title>
     <link href="http://qiuliang.github.io/tech/2015/10/18/jenkins-shell-restart-tomcat.html"/>
     <updated>2015-10-18T00:00:00+08:00</updated>
     <id>http://qiuliang.github.io/tech/2015/10/18/jenkins-shell-restart-tomcat</id>
     <content type="html">&lt;p&gt;在前一篇文章中，介绍了&lt;a href=&quot;http://www.qiuliang.net/tech/2015/10/02/git-nexus-jenkins-ci.html&quot;&gt;如何利用jenkins来搭建一个持续集成平台&lt;/a&gt;，该平台可以帮助我们完成从获取代码、编译、打包、部署等一系列的事情，极大的方便了我们的日常开发工作。&lt;/p&gt;

&lt;p&gt;但在实际使用中发现，之前使用的部署方式，是基于tomcat的热部署，这种方式不是很稳定，尤其在部署次数多了以后，经常出现内存溢出等错误，需要人工干预，这显然不是我们所希望的结果。如果是在一个比较大的研发团队，一般都会有一套自己开发的比较成熟的部署平台，比如我之前所在的团队，专门开发了一套自动化部署平台，简单来说就是在目标server上安装一个agent，利用该agent，可以干很多事情，比如执行前、后置脚本，收集日志、监控server等等。如果在一个创业型的中小规模技术团队，这个事情的成本是比较高的，因此需要另想办法。&lt;/p&gt;

&lt;p&gt;其实解决部署稳定性的问题，一个比较简单的办法就是部署前先停止应用，部署完成后再把应用启动起来。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果你的业务无法忍受短暂的停机，需要考虑部署时的容错，该方案不在本文讨论之列。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;有了大致思路，开始实施就比较简单了，最后总结为如下几个点：&lt;/p&gt;

&lt;h2 id=&quot;jenkins-serverserverssh&quot;&gt;首先需要建立jenkins server和目标server的ssh信任关系&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;ssh-keygen -t &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;rsa&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;dsa&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
ssh-copy-id -i ~/.ssh/id_rsa.pub user@your_ip_address&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;section&quot;&gt;编写重启脚本&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# author : qiuliang&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# date : 2015-10-15&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# =====deploy变量=====&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 应用程序的context path，如果是根路径，变量值为 ROOT&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;app_context_path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;salesvc
&lt;span class=&quot;c&quot;&gt;# 应用程序端口号&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;app_port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;8082
&lt;span class=&quot;c&quot;&gt;# tomcat目录名称应该满足如下规范，例如：tomcat-端口号&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;app_tomcat_path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/home/work/tomcat-8082
&lt;span class=&quot;c&quot;&gt;# build完成的war包名称&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;war_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;api-1.0-SNAPSHOT.war
&lt;span class=&quot;c&quot;&gt;# war包地址&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;war_url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;http://ci.aaa.com/job/api-sales/api/1.0-SNAPSHOT/api-1.0-SNAPSHOT.war&amp;#39;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# =====deploy变量 end=====&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 进入tomcat应用程序目录&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$app_tomcat_path&lt;/span&gt;/webapps
&lt;span class=&quot;c&quot;&gt;# 备份最近一次的包&lt;/span&gt;
mv &lt;span class=&quot;nv&quot;&gt;$app_context_path&lt;/span&gt;.war &lt;span class=&quot;nv&quot;&gt;$app_context_path&lt;/span&gt;.war.bak
&lt;span class=&quot;c&quot;&gt;# 下载最后一次build的包，该地址需要根据应用具体地址修改&lt;/span&gt;
wget &lt;span class=&quot;nv&quot;&gt;$war_url&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# kill tomcat实例&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;tomcat_pid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;/usr/sbin/lsof -n -P -t -i :&lt;span class=&quot;nv&quot;&gt;$app_port&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; -n &lt;span class=&quot;s2&quot;&gt;&amp;quot;$tomcat_pid&amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;kill&lt;/span&gt; -9 &lt;span class=&quot;nv&quot;&gt;$tomcat_pid&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 删除应用程序目录&lt;/span&gt;
rm -fr &lt;span class=&quot;nv&quot;&gt;$app_tomcat_path&lt;/span&gt;/webapps/&lt;span class=&quot;nv&quot;&gt;$app_context_path&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 重命名context path&lt;/span&gt;
mv &lt;span class=&quot;nv&quot;&gt;$war_name&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$app_context_path&lt;/span&gt;.war
&lt;span class=&quot;c&quot;&gt;# 重新启动tomcat&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;JAVA_HOME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/local/jdk1.7.0_79
&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$app_tomcat_path&lt;/span&gt;/bin/
./startup.sh&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;jenkins-job&quot;&gt;修改jenkins job配置&lt;/h2&gt;

&lt;p&gt;增加build post步骤，选择shell：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;ssh 192.168.220.180 &lt;span class=&quot;s1&quot;&gt;&amp;#39;bash -x -s&amp;#39;&lt;/span&gt; &amp;lt; api/src/main/resources/ci/deploy_test.sh&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;完成上述步骤后，执行job，如果最终显示SUCCESS，则大功告成。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>基于git、maven、nexus、jenkins搭建适合中小型技术团队的CI平台</title>
     <link href="http://qiuliang.github.io/tech/2015/10/02/git-nexus-jenkins-ci.html"/>
     <updated>2015-10-02T00:00:00+08:00</updated>
     <id>http://qiuliang.github.io/tech/2015/10/02/git-nexus-jenkins-ci</id>
     <content type="html">&lt;blockquote&gt;
  &lt;p&gt;在阅读本文前，假设你对git、maven有了一个基本的了解，也包括一些其他的专有名词，如不了解，建议查阅官方资料或直接google。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;为什么要搭建这样一个平台？&lt;/h2&gt;

&lt;p&gt;对于一个稍具规模的研发团队来说，每个角色都各司其职，如果没有一套很好的开发流程和管理手段，那在进行一些相对复杂的项目开发时，因开发流程不规范、管理和沟通效率低下带来的各种问题会层出不穷，大家也会手忙脚乱，不利于项目发展和团队配合。因此搭建一套适合自己团队的持续集成平台，是一个非常重要的事情，至少可以带来如下收益：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;规范的代码分支管理&lt;/li&gt;
  &lt;li&gt;快速的构建&lt;/li&gt;
  &lt;li&gt;尽早的集成&lt;/li&gt;
  &lt;li&gt;提升多项目、多版本的并行能力&lt;/li&gt;
  &lt;li&gt;更可靠的代码和更稳健的应用&lt;/li&gt;
  &lt;li&gt;前后端更彻底的解耦和配合&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ci&quot;&gt;CI系统结构&lt;/h2&gt;

&lt;p&gt;基于团队的实际情况，我们搭建了如下的CI平台，基本都是用开源组件实现，其结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/blog/ci-archetect.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;h5pc-web&quot;&gt;项目开发普通流程（主要是指H5/PC Web）&lt;/h3&gt;

&lt;p&gt;先简单介绍下我们的开发模式：一般将项目分为前后端两个team，前端team负责UI、样式、前端JS逻辑交互、异步渲染等工作；后端team主要负责数据加工、逻辑处理、持久化、分布式cache等工作。&lt;/p&gt;

&lt;p&gt;基于以上分工，一个常规的开发流程一般是这样的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;设计师设计UI&lt;/li&gt;
  &lt;li&gt;前端制作人员制作成HTML原型&lt;/li&gt;
  &lt;li&gt;后端开发人员进行rest接口开发&lt;/li&gt;
  &lt;li&gt;前端人员进行UI交互开发（过程中使用mock进行接口数据模拟，逐步过渡到后端开发人员提供的真实接口）&lt;/li&gt;
  &lt;li&gt;前、后端人员在项目开发中期开始在CI平台进行构建和集成&lt;/li&gt;
  &lt;li&gt;反复debug、持续构建，直至达到RC版本&lt;/li&gt;
  &lt;li&gt;上线、打tag&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用这种开发模式，我认为可以带来如下好处：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;分工清晰、职责明确&lt;/li&gt;
  &lt;li&gt;每个开发人员更加专注于自己的工作&lt;/li&gt;
  &lt;li&gt;系统边界清晰，封装更合理规范
    &lt;ul&gt;
      &lt;li&gt;对于后端开发人员来说，提供的api是给团队内另外的人来使用，因此在封装的时候，包括url、入参、出参等细节考虑更周全，更易于理解；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;前后端的debug更加容易&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;接下来针对该方案，介绍一下几个主要的系统组件的安装和配置方式。&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我们的标准环境一般是基于CentOS 6.5的最小化安装。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;gitlab&quot;&gt;gitlab安装和配置&lt;/h2&gt;

&lt;p&gt;git已经越来越流行，基本上成了互联网研发团队的标配，其灵活的分支模型以及强大的分布式仓库管理能力，对于管理大型项目复杂代码，完全能游刃有余，再搭配上gitlab，图形化的代码管理、简单易用的分支、tag管理，和基本的wiki、issue管理，现在gitlab已经开始出收费的版本了，但即便是免费的社区版本，功能已经是完全够用的。&lt;/p&gt;

&lt;p&gt;另外要强调一下的是gitlab所提供的pull request或者说code review功能，非常的不错，这对提高团队代码质量能起到很大的作用。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;步骤&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;基本按照官网操作步骤即可，以下操作可能会因版本变化而有所差异&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-2&quot;&gt;1. 安装必须的依赖组件&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;sudo yum install curl openssh-server postfix cronie
sudo service postfix start
sudo chkconfig postfix on
sudo lokkit -s http -s ssh&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;gitlab-rpm&quot;&gt;2. 安装gitlab rpm包&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; sudo bash
sudo yum install gitlab-ce
rpm -i gitlab-ce-XXX.rpm&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;gitlab-1&quot;&gt;3. 启动gitlab&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;sudo gitlab-ctl reconfigure&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;host&quot;&gt;4. 访问host地址，使用默认的如下管理员账号可进行配置修改&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;Username: root
Password: 5iveL!fe&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;mavennexus&quot;&gt;maven私服（nexus）安装和配置&lt;/h2&gt;

&lt;p&gt;nexus的安装过程比较简单，从官网下载nexus压缩包后，直接解压到工作目录，执行如下命令即可：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;./bin/nexus console&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;jenkins&quot;&gt;jenkins安装和配置&lt;/h2&gt;

&lt;h3 id=&quot;jenkins-1&quot;&gt;jenkins是什么？&lt;/h3&gt;

&lt;p&gt;简单来说，就是一个能提高开发人员效率的工具，减少一些重复的工作，例如：编译一个软件项目，通过cron去运行一个自动化任务。主要关注点如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;持续build/testing一个软件项目&lt;/li&gt;
  &lt;li&gt;监控外部job的执行情况&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;安装&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;java version “1.7.0_85”
jenkins version : 1.624&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;安装相关包：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;- sudo wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo
- sudo rpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.key
- sudo yum install jenkins&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;启动服务：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;- sudo service jenkins start/stop/restart
- sudo chkconfig jenkins on&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;jenkins web端默认为8080端口，请确认防火墙是否打开。&lt;/p&gt;

&lt;p&gt;如果上面步骤都顺利的话，打开地址：Http://localhost:8080应该可以看到jenkins的管理界面了。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;配置&lt;/h3&gt;

&lt;h4 id=&quot;git&quot;&gt;1. 安装git插件&lt;/h4&gt;

&lt;p&gt;默认没有集成git，需要先安装相关插件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;git plugin&lt;/li&gt;
  &lt;li&gt;git client plugin&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;centosgit&quot;&gt;2. 升级CentOS下的git客户端&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;因为jenkins的git插件需要使用1.7.9以上版本，而CentOS 6.5自带的git是1.7.1版本，需要先升级CentOS下的git。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;rpm –import http://apt.sw.be/RPM-GPG-KEY.dag.txt&lt;/li&gt;
  &lt;li&gt;安装RPMForge源：rpm -i http://pkgs.repoforge.org/rpmforge-release/rpmforge-release-0.5.3-1.el6.rf.x86_64.rpm
        注意选择不同的版本：http://pkgs.repoforge.org/rpmforge-release/&lt;/li&gt;
  &lt;li&gt;查看可用的git模块：yum –enablerepo=rpmforge-extras provides git&lt;/li&gt;
  &lt;li&gt;安装适合当前系统的版本：yum –enablerepo=rpmforge-extras install git-1.7.12.4-1.el6.rfx.x86_64&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;maven&quot;&gt;3. 配置maven&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;下载maven http://maven.apache.org/download.cgi&lt;/li&gt;
  &lt;li&gt;编辑环境变量：vi /etc/profile&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;M2_HOME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/local/apache-maven-3.3.3
&lt;span class=&quot;nv&quot;&gt;PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$PATH&lt;/span&gt;:&lt;span class=&quot;nv&quot;&gt;$JAVA_HOME&lt;/span&gt;/bin:&lt;span class=&quot;nv&quot;&gt;$M2_HOME&lt;/span&gt;/bin
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;环境变量生效：source /etc/profile&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;jenkinsmaven&quot;&gt;3.1 在jenkins管理端配置maven&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/images/blog/jenkins-maven.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在打包的时候，这个地方遇到了一个比较大的坑，主要是我的jenkins server安装在mac下的pd虚机上，如果使用默认的maven中央库的话，会一直报一个错误：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;应该是虚机的网络问题，无法连接到https协议的中央库，后来修改maven使用了oschina的第三方库后解决。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在jenkins执行job时又遇到了文件权限的错误，默认情况下maven生成的包位于如下目录：/var/lib/jenkins/jobs/test/workspace/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;需要修改执行jenkins用户对该目录的写入权限。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;错误：Jenkins needs to know where your Maven is installed.
这个问题的主要原因是全局系统设置中的maven的几个配置不正确，主要配置Maven、Maven Installation几个配置节。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;jdk&quot;&gt;4. 配置JDK&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/blog/jenkins-jdk.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在系统全局设置里面，进行JDK的配置：&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;5. 配置部署插件&lt;/h4&gt;

&lt;p&gt;到插件管理模块中安装：Deploy to container Plugin&lt;/p&gt;

&lt;p&gt;增加自动化部署的配置：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/blog/jenkins-deploy.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;job&quot;&gt;新建一个job&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;选择构建一个maven项目&lt;/li&gt;
  &lt;li&gt;选择需要的jdk版本&lt;/li&gt;
  &lt;li&gt;设置git代码分支地址和身份验证信息&lt;/li&gt;
  &lt;li&gt;选择pom文件的相对路径&lt;/li&gt;
  &lt;li&gt;设置deploy的target&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;完成以上安装和配置工作后，基本上一套标准的CI工作流程就能跑起来了，enjoy！&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>git分支模型探讨</title>
     <link href="http://qiuliang.github.io/tech/2015/07/25/git-branch-module.html"/>
     <updated>2015-07-25T00:00:00+08:00</updated>
     <id>http://qiuliang.github.io/tech/2015/07/25/git-branch-module</id>
     <content type="html">&lt;p&gt;在阅读本文之前，假设你已经熟悉了git的常用命令，并且对git的分支模型有了基本的了解。&lt;/p&gt;

&lt;p&gt;基础常用命令：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;git clone&lt;/li&gt;
  &lt;li&gt;git add&lt;/li&gt;
  &lt;li&gt;git commit &lt;/li&gt;
  &lt;li&gt;git push&lt;/li&gt;
  &lt;li&gt;git checkout&lt;/li&gt;
  &lt;li&gt;git branch&lt;/li&gt;
  &lt;li&gt;git fetch&lt;/li&gt;
  &lt;li&gt;git merge&lt;/li&gt;
  &lt;li&gt;git pull&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于git分支模型，建议先阅读如下资料：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/07/git.html&quot;&gt;阮一峰整理的一个比较简单的git分支模型&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md&quot;&gt;较为全面的几种git分支模型介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如下是网络上流传比较广泛的一个较为成熟的git分支示意图，基本能满足一般团队或个人进行代码管理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/blog/git/4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但每个team都有自己的需求和特点，生搬硬套不一定是合适的，和同事花1个多小时的时间讨论了一下，认为适合我们team的分支模型，大致如下。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;需求背景&lt;/h2&gt;

&lt;p&gt;主要的需求如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;能支持日常迭代开发、紧急线上bug修复、多功能并行开发&lt;/li&gt;
  &lt;li&gt;大概50人左右的团队，平日迭代项目较多，且周期短（1~2周一个迭代）&lt;/li&gt;
  &lt;li&gt;能够通过tag重建整个系统&lt;/li&gt;
  &lt;li&gt;支持code review&lt;/li&gt;
  &lt;li&gt;所有上线的代码必须都是经过测试保证，且能自动同步到下一次的迭代中&lt;/li&gt;
  &lt;li&gt;能和公司的项目管理/持续集成系统整合&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;分支模型说明&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1. 日常迭代&lt;/h3&gt;

&lt;h4 id=&quot;section-3&quot;&gt;1.1 流程说明&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;项目负责人先初始化仓库&lt;/li&gt;
  &lt;li&gt;拉分支，同时包括develop和release分支&lt;/li&gt;
  &lt;li&gt;develop分支开发完成后，提交pull requests到release分支&lt;/li&gt;
  &lt;li&gt;进行code review，通过则merge到release分支&lt;/li&gt;
  &lt;li&gt;在release分支上进行build和生成上线包&lt;/li&gt;
  &lt;li&gt;部署上线包，上线完成后再merge到master，并打tag&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/blog/git/1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;1.2 后续迭代流程&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;从master上一次tag处拉出分支，同时包括dev和release&lt;/li&gt;
  &lt;li&gt;在dev上进行开发和提交&lt;/li&gt;
  &lt;li&gt;开发完成后，提交pull request到release分支&lt;/li&gt;
  &lt;li&gt;进行code review，通过则merge到release分支&lt;/li&gt;
  &lt;li&gt;在release分支上进行build和生成上线包&lt;/li&gt;
  &lt;li&gt;部署上线包，上线完成后再merge到master，并打tag&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/blog/git/2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;2. 在正常迭代同时有紧急线上问题修复&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;迭代分支同上&lt;/li&gt;
  &lt;li&gt;同时再拉出hotfix开发和hotfix_release分支&lt;/li&gt;
  &lt;li&gt;此时迭代和hotfix分支并行开发&lt;/li&gt;
  &lt;li&gt;如果hotfix开发完成，并在hotfix_release分支进行提测并上线&lt;/li&gt;
  &lt;li&gt;那么在迭代开发进行pull request前，应该要求先从master分支进行一次merge&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/blog/git/3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;3. 多功能并行&lt;/h3&gt;

&lt;p&gt;理论上和hotfix分支模型没有区别。&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;相关规范&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;开发人员不应该操作master分支&lt;/li&gt;
  &lt;li&gt;由每个迭代或项目的负责人来进行code review和进行merge操作&lt;/li&gt;
  &lt;li&gt;各开发分支和release分支均应该push到远程仓库&lt;/li&gt;
  &lt;li&gt;日常迭代和release分支在开发完成后应该被删除&lt;/li&gt;
  &lt;li&gt;多人协作，应该使用同一个远程分支&lt;/li&gt;
  &lt;li&gt;每次发起pull request前，都需要先从master分支merge代码&lt;/li&gt;
&lt;/ul&gt;
</content>
   </entry>
   
   <entry>
     <title>创新是这个世界的源动力 —《从0到1》</title>
     <link href="http://qiuliang.github.io/book/2015/07/18/zero-to-one.html"/>
     <updated>2015-07-18T00:00:00+08:00</updated>
     <id>http://qiuliang.github.io/book/2015/07/18/zero-to-one</id>
     <content type="html">&lt;p&gt;&lt;img src=&quot;http://img3.douban.com/lpic/s28012945.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;大概1个多月以前，领导向我们推荐了这本书，来自于硅谷创业教父Peter Thiel的大作，如果你还不甚了解Peter，推荐自行google，简单来说，就是Paypal的founder之一，后来又在很早的时候投资了Facebook，以及在硅谷参与或投资了众多的科技公司。而这本书，我想就是peter在创立或投资一家公司时的一些总结和思考，其中大部分的内容，来源于其在斯坦福的一次分享。&lt;/p&gt;

&lt;p&gt;书的篇幅不长，各个章节之间也并没有严密的逻辑关系，在这些看似分散、跳跃的片段中，能否真的找到商业的秘密？我想答案一定是否定的，毕竟在这个复杂的世界里，没有什么一成不变的事情，今天的秘密，不过是明天的常识而已。而作者除了教导我们一些自身的经验之外，更多的是希望引发读者对未来、对商业、对创新的一些思考。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;关于过去和未来&lt;/h2&gt;

&lt;p&gt;了解历史，正视历史，对于每一个科技创业者甚至于对每一个人而言，都有着非同寻常的意义。peter在本书中，花了较长的篇幅和详细的数据，来向我们说明了90年中后期开始的互联网泡沫，从何而来，又如何破灭。无数的公司在那场盛筵中从巅峰跌落至谷底，只有少之又少的公司经受住了考验，并逐渐的开始开花结果，peter所创立的Paypal就是其中之一，这样的经验对于每一个创业者来说，都是应该要重视和思考的。经验一定不应该是教条式的，它应该能引发我们思考：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;大胆尝试胜过于平庸保守&lt;/li&gt;
  &lt;li&gt;坏计划也好过没计划&lt;/li&gt;
  &lt;li&gt;竞争性市场很难赚钱&lt;/li&gt;
  &lt;li&gt;营销和产品同样重要&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;世上没有人可以精准的预测未来，能看清楚未来一两年的人，已经非比一般；而能看清楚未来五到十年的人，已然超越了这世界绝大多数的普通人，至于更遥远的未来，应该只有神能做到了吧？&lt;/p&gt;

&lt;p&gt;对于科技创业者，有一点却是毋庸置疑的，那就是未来，一定是进步的。在这个进步的未来中，保持敏锐的嗅觉，或许能让我们在未来的道路上，不至于走偏。而如果你恰巧知道了某一领域从无到有，从0到1的秘密，这样做出一番事业的几率应该会大大提升。&lt;/p&gt;

&lt;p&gt;书中提出的一些观点，我们应该反复思考：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果你想创造并获得持久的价值，不要只是跟风建立一个没有特色的企业。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这一点其实对个人也同样适用，如果你想与众不同或是出类拔萃，不要跟风，做你自己，做真正有价值的事情。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在完全竞争中，企业着眼于短期利益，不可能对未来进行长期规划。要想将企业从每日的生存竞赛中解脱出来，唯一的方法就是：获取垄断利润。而失败的企业原因却相同：它们都无法逃脱竞争。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这应该就是peter想向我们表达的一些商业的秘密，却有太多的人看不清楚。因此，新思想是一个初创公司最重要的力量，质疑现有观念，从零开始重新审视自己所做的一切。在任何一次潮流到来的时候，我们不是应该去抵制或是盲从，在潮流中保持独立的思考才是我们应该做的。&lt;/p&gt;

&lt;p&gt;关于如何建立一个垄断企业，peter也给了我们一些建议，例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;占领小市场&lt;/li&gt;
  &lt;li&gt;扩大规模&lt;/li&gt;
  &lt;li&gt;破坏性创新&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前人的经验，只是我们的一个指引，如何去做，最终决定权在于你自己。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;关于秘密&lt;/h2&gt;

&lt;p&gt;现在我们所知道的常识，在过去就是秘密。举几个科技方面的案例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;人们虽然相隔万里，却能用电脑或手机利用网络进行面对面的交流&lt;/li&gt;
  &lt;li&gt;随时随地使用手机来购物，并进行支付&lt;/li&gt;
  &lt;li&gt;个人飞行背包也已经试飞成功&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些在过去几百上千年到最近十年的时间里，都被认为是天方夜谭或是完全不为人知的秘密。但现在却有很大一部分人是不愿意探索秘密的，大致总结为如下几个原因：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;我们从小受到的教育是渐进主义式的&lt;/li&gt;
  &lt;li&gt;害怕犯错，规避风险，自然也就错失了探索秘密的机会&lt;/li&gt;
  &lt;li&gt;过于自满&lt;/li&gt;
  &lt;li&gt;现在扁平化的世界，使人们怀疑自己对秘密的探索&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可事实还是有许多秘密等着我们去探索，在商业上也是一样，成功的企业建立于开放却未知的秘密之上，想想这些公司：Google解决了人们对信息的强烈需求；Airbnb解决了游客和业主的实际需求；Uber则在出行上打破常规。&lt;/p&gt;

&lt;p&gt;好的企业是改变世界的密谋者。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;有意思的创始人&lt;/h2&gt;

&lt;p&gt;关于创始人和初创团队，peter发现了一个有趣的现象：很多成功的初创公司的创始人团队，都有着个性鲜明或特立独行的一面。这些特质或是天生，但大多数我认为是后天环境影响改变，这个改变遵循着一个规律：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;自己将其夸大&lt;/li&gt;
  &lt;li&gt;其他人将其夸大&lt;/li&gt;
  &lt;li&gt;真正的不同&lt;/li&gt;
  &lt;li&gt;发展为极端特质&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;想想自己或是身边的人，是不是觉得很有道理？比如你做了一件自认为不错的事情，然后分享给你周围的人，他们也觉得你很牛逼，这个时候迫于压力或是迫于面子，你需要把这件事情真正做好，周而复始，在某个领域你将越来越牛。我想这应该是符合心理学或是人性的需要吧。&lt;/p&gt;

&lt;p&gt;当然，拥有这样特质的人不一定会创立企业，但大多都会经营自己的个人品牌，比如LadyGaga，她生来如此吗？我想未必吧。这样的人或许生来矛盾，具有这种特质的人，从概率上来讲，创立一个成功企业的几率确实比常人大。不过，再非同寻常的人也不及一个优秀团队的力量来的大。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;结语&lt;/h2&gt;

&lt;p&gt;不管未来的趋势如何，我们都应该相信，未来不是自行发生的，它取决于你、我和我们身边的每一个人，无所作为，还是尽力而为？取决于我们自己；在日常中创新，在常规中重构，打破旧有思维的禁锢，保持独立的思考，才有可能从0到1。&lt;/p&gt;

</content>
   </entry>
   
   <entry>
     <title>Markdown资源分享</title>
     <link href="http://qiuliang.github.io/tool/2014/11/27/markdown-resource-share.html"/>
     <updated>2014-11-27T00:00:00+08:00</updated>
     <id>http://qiuliang.github.io/tool/2014/11/27/markdown-resource-share</id>
     <content type="html">&lt;p&gt;&lt;code&gt;Markdown&lt;/code&gt;的核心，就是使用极为简单的标记语法，来书写具备良好外观格式的文档解析工具，使作者的核心关注在文档内容本身，而不是如何排版上。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;常用语法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;标题&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;# 标题一&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;## 标题二&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;### 标题N&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;有序/无序列表&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;- item
- item2

1. item1
2. item2&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;引用&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&amp;gt; 这里是引用内容&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;强调加粗&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;**这里是加粗内容**&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;行内代码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是一个&lt;code&gt;行内代码&lt;/code&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;这里是行内代码&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;代码高亮&lt;/strong&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;sb&quot;&gt;```&lt;/span&gt; ruby
&lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;test1&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; a.gsub&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;/&lt;span class=&quot;se&quot;&gt;\d&lt;/span&gt;+/,&lt;span class=&quot;s1&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
print a&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
print b&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
a.gsub!&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;/&lt;span class=&quot;se&quot;&gt;\d&lt;/span&gt;+/,&lt;span class=&quot;s1&quot;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;sb&quot;&gt;```&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;section-1&quot;&gt;推荐工具&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;客户端工具&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://markdownpad.com/&quot;&gt;MarkdownPad&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.mdcharm.com/&quot;&gt;MdCharm&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://pad.haroopress.com/&quot;&gt;Haroopad&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://25.io/mou/&quot;&gt;Mou&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://atom.io/&quot;&gt;Atom&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;markdown&quot;&gt;在线Markdown编辑器&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://dillinger.io&quot;&gt;dillinger.io&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackedit.io/editor&quot;&gt;stackedit&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zybuluo.com/mdeditor&quot;&gt;CmdMarkdown&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://maxiang.info&quot;&gt;马克飞象&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上这些，是我平时收集的&lt;code&gt;Markdown&lt;/code&gt;文档编辑工具，几乎都是免费和开源工具，相信总有一款适合你，我个人平时使用&lt;code&gt;Haroopad&lt;/code&gt;、&lt;code&gt;Atom&lt;/code&gt;比较多一些。&lt;/p&gt;

&lt;p&gt;如果上面的链接打开速度比较慢，请&lt;code&gt;翻墙&lt;/code&gt;，推荐翻墙服务：&lt;a href=&quot;http://refyt.com/?r=da2d2836b60e42ff&quot;&gt;云梯&lt;/a&gt;，该链接带有我的推荐码，你可以优惠10元，我可以得收益10元，谢谢！&lt;/p&gt;

&lt;p&gt;Powered by Haroopad&lt;/p&gt;
</content>
   </entry>
   
 
</feed>

