<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>Qiuliang's Site</title>
   <link href="http://qiuliang.github.io/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://qiuliang.github.io" rel="alternate" type="text/html" />
   <updated>2017-12-02T22:01:03+08:00</updated>
   <id>http://qiuliang.github.io</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>ZooKeeper 简介及应用</title>
     <link href="http://qiuliang.github.io/tech/2017/10/19/zookeeper-overview.html"/>
     <updated>2017-10-19T00:00:00+08:00</updated>
     <id>http://qiuliang.github.io/tech/2017/10/19/zookeeper-overview</id>
     <content type="html">&lt;p&gt;早几年就接触过ZooKeeper，应用不算深入，理解不算透彻，趁着近期略有闲暇，觉得有必要把相关的知识点梳理和总结一下。&lt;/p&gt;

&lt;h2 id=&quot;zookeeper-&quot;&gt;ZooKeeper 简介&lt;/h2&gt;

&lt;p&gt;简单来讲，ZooKeeper 就是一个可扩展的高吞吐分布式协调系统。
基本上通过解答以下几个问题，能大致对 ZooKeeper 做一个快速的了解。 &lt;/p&gt;

&lt;h3 id=&quot;zookeeper--1&quot;&gt;ZooKeeper 是什么？&lt;/h3&gt;

&lt;p&gt;其前身由yahoo开发（目前已成为Apache的一个顶级项目），用于解决分布式系统中的数据一致性问题，因所有的分布式系统都会面临这一问题，所以在开发hadoop时将这个问题抽象出来，提出了一个独立和通用的解决方案，也就是现在的zookeeper。由于zookeeper具备如下的优势，逐步成为很多知名分布式系统的基础组件，例如：hadoop、kafka、dubbo等。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;设计目标&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;类似于标准文件系统，各个进程之间的协调通过共享分级命名空间，目录或者文件被称为 &lt;code&gt;znodes&lt;/code&gt; ，这些数据都会被保存到zk的实例内存中&lt;/li&gt;
  &lt;li&gt;以集群形式提供服务&lt;/li&gt;
  &lt;li&gt;有序性&lt;/li&gt;
  &lt;li&gt;高性能&lt;/li&gt;
  &lt;li&gt;极简api
  一共7个（create、delete、exist、get data、set data、get children、sync）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;zookeeper--2&quot;&gt;ZooKeeper 结构&lt;/h3&gt;

&lt;p&gt;一般来讲，ZooKeeper 服务集群由大于等于3的单数个服务器构成，在每台服务器内存中维护类似于文件系统的树形数据结构，其中的一台作为主控节点，其余作为从属节点。写操作只能由主控节点响应，读可由任务节点响应，如果服务期间主控节点宕机，则其余节点可再选举出新的主控节点。&lt;/p&gt;

&lt;p&gt;从这个结构设计来看，主控节点因只有一个，在写操作上天然存在瓶颈，所以更适合读多写少的应用场景。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;集群结构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/zk-arch.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;节点模型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017/zk-node.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;zookeeper--3&quot;&gt;ZooKeeper 优势&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;基于watcher的通知回调机制，基于该机制，可实现配置管理的热加载、服务注册和发现等等&lt;/li&gt;
  &lt;li&gt;性能表现优异，能支撑上万客户端的并发操作&lt;/li&gt;
  &lt;li&gt;使用zab作为其一致性协议实现，简单介绍一下，zab协议脱胎于Paxos，后者以难于理解和实现著称，更多是在学术界研究，工程难以实施，而 zab 协议简化了 Paxos 中的二阶段提交，提升了系统性能；利用自增序列，保证了顺序处理逻辑以及更容易的故障恢复实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;主要应用场景&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;分布式锁&lt;/li&gt;
  &lt;li&gt;服务注册&lt;/li&gt;
  &lt;li&gt;配置管理&lt;/li&gt;
  &lt;li&gt;名称服务&lt;/li&gt;
  &lt;li&gt;分布式锁&lt;/li&gt;
  &lt;li&gt;leader选举&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;quick-start&quot;&gt;Quick Start&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;系统要求&lt;/h3&gt;

&lt;p&gt;zookeeper server 端可运行于主流linux发行版和windows之上，软件环境需要依赖jdk，版本大于1.7即可。
如采用集群方式部署，3个节点是最小化要求。&lt;/p&gt;

&lt;p&gt;据官方介绍，zk对硬件要求不是很高，2 Core / 2G RAM / 80G 即可。&lt;/p&gt;

&lt;p&gt;本文环境信息：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;centos 6.6&lt;/li&gt;
  &lt;li&gt;openjdk 1.8&lt;/li&gt;
  &lt;li&gt;zookeeper 3.4.8&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;配置文件&lt;/h3&gt;

&lt;p&gt;一般位于 ./conf/zoo.cfg，示例如下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nv&quot;&gt;tickTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2000
&lt;span class=&quot;nv&quot;&gt;dataDir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/var/lib/zookeeper
&lt;span class=&quot;nv&quot;&gt;clientPort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2181
&lt;span class=&quot;nv&quot;&gt;initLimit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;5
&lt;span class=&quot;nv&quot;&gt;syncLimit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2
server.1&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;zoo1:2888:3888
server.2&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;zoo2:2888:3888
server.3&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;zoo3:2888:3888&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;section-4&quot;&gt;几个容易理解错误的配置&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;initLimit  # The number of ticks that the initial synchronization phase can take&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;初始连接到 leader 节点的超时时间，具体的 value 指 tickTime 的倍数，如果设置为5，则超时为10秒。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;syncLimit  # The number of ticks that can pass between sending a request and getting an acknowledgement&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;集群中 follower 到 leader 的每次请求超时时间&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;集群信息配置&lt;/h4&gt;

&lt;p&gt;server.{no}={host}:{cordinate_port}:{election_port}&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;no  # 服务器编号&lt;/li&gt;
  &lt;li&gt;host  # 服务器IP或主机名&lt;/li&gt;
  &lt;li&gt;cordinate_port  # 主从server之间的通讯端口&lt;/li&gt;
  &lt;li&gt;election_port  # 选举端口&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;命令行工具&lt;/h3&gt;

&lt;h4 id=&quot;server&quot;&gt;启动server&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;./bin/zkServer.sh start&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;section-7&quot;&gt;四字命令&lt;/h4&gt;

&lt;p&gt;结合网络工具 nc ，zookeeper 提供了一些四字命令来查询服务器相关信息，例如：&lt;/p&gt;

&lt;p&gt;查看该服务器上的统计信息：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;echo &lt;/span&gt;stat &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; nc 127.0.0.1 2181&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;输出如下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;Latency min/avg/max: 0/0/4372
Received: 97613067
Sent: 97613133
Connections: 7
Outstanding: 0
Zxid: 0x6000beb9a
Mode: leader
Node count: 150&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;zkclish&quot;&gt;zkCli.sh&lt;/h4&gt;

&lt;p&gt;zookeeper 提供了一个类 shell 的一个客户端工具 zkCli.sh ，可方便查看服务器信息和进行相关管理操作。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;sh ./zkCli.sh -server 127.0.0.1:2181&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;section-8&quot;&gt;常见问题&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;如启动失败，会在 ./bin 目录下生成 zookeeper.out 文件，可查询具体出错原因。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;myid&quot;&gt;缺少myid文件&lt;/h4&gt;

&lt;p&gt;/var/lib/zookeeper/myid file is missing&lt;/p&gt;

&lt;p&gt;到相应目录创建该文件，并编辑该文件的值为当前 server 的序号。&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://zookeeper.apache.org/doc/trunk/zookeeperOver.html&quot;&gt;官方Overview&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>redis pipeline和mget、mset</title>
     <link href="http://qiuliang.github.io/tech/2017/09/19/redis-pipeline-mget-mset.html"/>
     <updated>2017-09-19T00:00:00+08:00</updated>
     <id>http://qiuliang.github.io/tech/2017/09/19/redis-pipeline-mget-mset</id>
     <content type="html">&lt;h2 id=&quot;pipeline&quot;&gt;为什么需要pipeline？&lt;/h2&gt;

&lt;p&gt;因为redis本身是基于request/response模式，每一个命令都需要等待上一个命令响应后进行处理，中间需要经过RTT（Round Time Trip，往返延时，表示发送端从发送数据开始，到发送端收到来自接收端的确认，所需要的时间。），并且需要频繁调用系统IO。&lt;/p&gt;

&lt;h2 id=&quot;pipeline-1&quot;&gt;pipeline应用场景&lt;/h2&gt;

&lt;p&gt;多个命令需要被及时提交，且这些命令的响应结果没有相互依赖。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;好处&lt;/h2&gt;

&lt;p&gt;可较大提升性能&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;需要注意&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;不要和常规命令client共用一个链接，因为pipeline是独占连接的，如果管道内命令太多，可能会造成请求超时&lt;/li&gt;
  &lt;li&gt;可发送命令数量受到客户端缓冲区大小限制，如超过限制，则flush到redis&lt;/li&gt;
  &lt;li&gt;redis server存在query buffer限制，默认是1GB，如果超过这个值，客户端会被强制断掉&lt;/li&gt;
  &lt;li&gt;redis server存在output buffer限制，受到maxmemory配置限制&lt;/li&gt;
  &lt;li&gt;要实现pipeline，同时需要服务器端和客户端的支持&lt;/li&gt;
  &lt;li&gt;redis cluster不建议使用pipeline，容易产生max redirect错误&lt;/li&gt;
  &lt;li&gt;twem proxy可以支持pipeline&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;局限性&lt;/h2&gt;
&lt;p&gt;当某个命令的执行需要依赖前一个命令的返回结果时，无法使用pipeline。&lt;/p&gt;

&lt;h2 id=&quot;mgetmset&quot;&gt;mget和mset&lt;/h2&gt;

&lt;p&gt;mset a “a1” b “b” c “c1”
mget a b c &lt;/p&gt;

&lt;p&gt;mget和mset命令也是为了减少网络连接和传输时间所设置的，其本质和pipeline的应用区别不大，但是在特定场景下只能用pipeline实现，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;get a
set b ‘1’
incr b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pipeline适合执行这种连续，且无相关性的命令。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;根据大家的测试反馈，在key数量非常多的时候，mget命令性能可能优于pipeline。（未做实测考证）&lt;/p&gt;
&lt;/blockquote&gt;

</content>
   </entry>
   
   <entry>
     <title>孩子就是我们的影子：关于家庭教育的一点思考</title>
     <link href="http://qiuliang.github.io/life/2017/04/25/family-education.html"/>
     <updated>2017-04-25T00:00:00+08:00</updated>
     <id>http://qiuliang.github.io/life/2017/04/25/family-education</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;学校教育能带给我们什么&lt;/h2&gt;

&lt;p&gt;大概在半年多以前，也就是去年的6、7月份，我们正忙着准备孩子入学报名的事情，这对我们来讲，无疑为一件大事，因为女儿从此就要进入人生中的一个新阶段：上小学。我们想象在两个月后，她应该坐在宽敞明亮的地方，会要认识很多新的小伙伴，她也许会觉得喜悦，但更多的可能是好奇，从此将要开始度过一段漫长、美好单纯的时光，同样也是充满了挑战和汗水的时光，这件事如此重要，以至于作为父母的我们会有一些焦虑，希望她在小学生活中收获快乐和友爱，同时也希望她能求知、明理，懂得付出才有收获，懂得坚持才有希望。&lt;/p&gt;

&lt;p&gt;而这些，我们也都清楚，如果完完全全把孩子交给学校，家长则作为旁观者，未来的结果一定是收获失望。在学校里，孩子与老师同学朝夕相处，从师长那里习得知识，从和同学的互动中习得与人沟通协作的能力，但更重要的是：孩子会从自己的原生家庭中，受到更直接、更强大的影响，家庭是因，学校里的表现是果。如果孩子在学校里的表现让我们失望，请先反思，我们是如何引导孩子，是如何去处理碰到的问题的？我们认为，其实不需要太多刻意的教育，孩子也从来都不需要被“教育”，她就是一张白纸，我们怎么做，孩子就会按照我们的实际行动，呈现出或优美、或杂乱的线条。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;我们如何影响孩子&lt;/h2&gt;

&lt;p&gt;孩子注意力不集中，做作业不认真。需要想一想，是否在孩子学习功课的时候，我们在看电视？或者在玩手机？
孩子总是乱放东西，玩完玩具铺满一地。需要想一想，我们自己的衣服、鞋子是否随手一扔？各种生活用品杂物也是到处都有？
孩子没有耐性爱着急。需要想一想，我们是否当着孩子的面，彼此争吵？是否在面对孩子的坏习惯时，我们按捺不住心头的怒气而呵斥孩子？
孩子不爱看书，喜欢看动画片。需要想一想，我们自己有多久没有看完过一本书？家里是否有随时开启阅读的氛围？有没有方便孩子拿取的书架？&lt;/p&gt;

&lt;p&gt;这些都只是家庭生活中一个个极小的片段，这些片段不断地累加，最终造就了你眼中的孩子，所有的结果都是我们自己的选择。既不能埋怨孩子，也不能寄希望于他人，家长必须为这样的结果负责，孩子的任何问题，最终也都能在家长身上找到那个最根本的因。孩子本就是我们的影子啊，作为她最亲近的人，你所说的话，所做的一切，都将对她产生潜移默化且巨大的影响，甚至很多事情无法用个性、偶然去解释，这种力量强大到我们自己都难以置信，但又实实在在的影响着我们、影响着我们的孩子。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;每个孩子都是天使&lt;/h2&gt;

&lt;p&gt;但即使家长做的再好，孩子总有犯错误的时候，面对孩子的问题，不要因为孩子的错误而湮没她身上的闪光点，用爱心和智慧让孩子感受教育的宽容和善良。没有一个孩子是不想得到周围人的肯定的，特别是父母的欣赏。如果孩子能受到最亲近的人的鼓励，便有了战胜一切困难的勇气和决心。&lt;/p&gt;

&lt;p&gt;我们所处的这个时代，急剧变化且精彩纷呈，信息的获取速度超越人类以往任何一个时期，但就孩子的教育问题上，我们很难从各种各样繁杂的声音中找出一个万能的方子。唯有不断探索和学习，不断试错和调整，做到知行合一，和孩子一起，努力成就更好的自我。在她的人生道路上，一起面对困难，帮助她成为她所期望的自己，而不是我们眼中所期望的样子。即使她现在还不完美，我们也要足够宽容和耐心，静待花开的时刻。&lt;/p&gt;

</content>
   </entry>
   
   <entry>
     <title>Java内存模型解析</title>
     <link href="http://qiuliang.github.io/tech/2016/09/14/jvm-ram-module.html"/>
     <updated>2016-09-14T00:00:00+08:00</updated>
     <id>http://qiuliang.github.io/tech/2016/09/14/jvm-ram-module</id>
     <content type="html">&lt;blockquote&gt;
  &lt;p&gt;基于HotSpot虚拟机&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;运行时数据区域&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;线程私有&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;程序计数器：相当于当前线程所执行字节码的行号指示器&lt;/li&gt;
  &lt;li&gt;java虚拟机栈：局部变量表部分，存放编译期可知的各种基本数据类型，其中64位的long和double占用2个Slot，其他占用1个Slot&lt;/li&gt;
  &lt;li&gt;本地方法栈：类似于java虚拟机栈，但本地方法栈为本地native方法服务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;线程共享&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;java堆，被所有线程共享，在虚拟机启动时创建&lt;/li&gt;
  &lt;li&gt;方法区，用于存放类信息、常量、静态变量，属于虚拟机的一个逻辑部分，但有个别名叫非堆（Non-Heap）&lt;/li&gt;
  &lt;li&gt;直接内存，NIO可以使用Native函数直接分配堆外内存&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/blog/2016/jvm-ram-module.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Sun HotSpot虚拟机使用永久代来实现方法区，因永久代有 -XX:MaxPermSize的上限， jdk 1.7以后，已经把原本放在方法区（永久代）中的字符串常量池移出&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;关于String.intern方法在JDK1.6和1.7中使用方法区内存方面的差异&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;String.intern是一个Native方法，如果字符串常量池中已包含一个等于此String对象的字符串，则返回常量池中代表这个字符串的String对象，否则，将此String对象包含的字符串添加到常量池中，并且返回String对象的引用。&lt;/p&gt;

&lt;p&gt;在JDK1.6中，intern()方法会把首次遇到的字符串实例复制到永久代中，而JDK1.7中不再复制实例，只是在常量池中记录首次出现的实例引用，对内存占用有较大减少。&lt;/p&gt;

&lt;p&gt;垃圾收集主要针对java堆，基本都采用分代收集算法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;新生代&lt;/li&gt;
  &lt;li&gt;老年代&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;还可以细分为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Eden空间&lt;/li&gt;
  &lt;li&gt;From Survivor空间&lt;/li&gt;
  &lt;li&gt;To Survivor空间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），
主流虚拟机在分配java堆内存空间时，都可以进行扩展，通过 -Xmx 和 -Xms控制，如果空间不够时，则抛出OutOfMemoryError。&lt;/p&gt;

&lt;h2 id=&quot;java&quot;&gt;Java堆中对象分配、布局和访问&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;对象分配&lt;/h3&gt;

&lt;p&gt;从虚拟机的视角来看new一个java对象的过程：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;检查类对象是否在常量池中存在这个类对象的符号引用&lt;/li&gt;
  &lt;li&gt;如果这个符号引用代表的类还没有加载、解析和初始化过，需要先执行相应的类加载过程&lt;/li&gt;
  &lt;li&gt;为对象分配内存，两种方式：指针碰撞（Serial、ParNew等带Compact过程的收集器）、空闲列表（CMS这种基于Mark-Sweep算法的收集器）&lt;/li&gt;
  &lt;li&gt;对对象进行必要的设置，包括是哪个类的实例、对象的哈希值、GC分代年龄，这些信息存放在对象头（Object Head）中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;内存分配并发问题的两种解决方案：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对分配内存的动作进行同步处理，保证更新操作的原子性&lt;/li&gt;
  &lt;li&gt;按照线程划分不同的空间进行，TLAB，只有TLAB空间用完时，才需要同步锁定，可通过参数：-XX:+/-UseTLAB&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;对象内存布局&lt;/h3&gt;

&lt;p&gt;分三块区域：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对象头（Header）&lt;/li&gt;
  &lt;li&gt;实例数据（Instance Data）&lt;/li&gt;
  &lt;li&gt;对齐填充（Padding）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对象头存储两部分数据，第一部分是对象自身的运行时数据，例如：哈希值、GC分代年龄、锁状态标志、线程持有的锁等。另一部分是类型指针，虚拟机通过这个指针来确定属于哪个类的实例。
实例数据存储程序代码中定义的各种字段内容。
对齐填充区域用于补全对象的起始地址是8字节的整数倍。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;对象访问&lt;/h3&gt;

&lt;p&gt;java程序通过栈上的引用指针来操作堆上的具体对象，具体如何访问取决于虚拟机的实现方式，主流有两种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用句柄&lt;/li&gt;
  &lt;li&gt;直接指针&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两种方式各有优劣，简单来说，句柄方式在reference中存储的是稳定的句柄地址，但需要两次寻址以获得对象实例数据和类型数据。直接指针节省了一次指针定位的时间开销。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Sun HotSpot使用直接指针来访问数据。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-4&quot;&gt;内存分配相关异常&lt;/h2&gt;

&lt;h3 id=&quot;javaoutofmemoryerror&quot;&gt;Java堆内存问题：OutOfMemoryError&lt;/h3&gt;

&lt;p&gt;如果出现了OutOfMemoryError的异常，需要确定是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;内存泄漏的意思是说GC无法对对象进行自动回收，如果是溢出，就是说内存中的对象还必须存活但空间不够了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;内存泄漏需要检查对象是通过怎样的路径和GC Roots相关联，内存溢出一般需要检查虚拟机堆参数：-Xms/-Xmx和物理内存的关系，以及从代码层面检查某些对象的生命周期。&lt;/p&gt;

&lt;h3 id=&quot;stackoverflowerroroutofmemoryerror&quot;&gt;虚拟机栈内存问题：StackOverflowError和OutOfMemoryError&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError&lt;/li&gt;
  &lt;li&gt;如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;栈容量由-Xss参数设定，-Xoss设置本地方法栈大小在HotSpot虚拟机中无效&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;虚拟机可用栈内存容量计算公式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;进程最大内存容量 - 最大堆容量（Xmx）- 最大方法区容量（MaxPermSize）= 虚拟机栈内存总容量&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;根据以上公式，如果每个线程所分配的栈容量越大，则可建立的线程数量就会减少。在开发多线程应用时，如果出现内存溢出，在不能减少线程数或者增加物理内存的情况下，可以考虑减少最大堆和栈容量来换取更多的线程数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-5&quot;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html&quot;&gt;Sun HotSpot VM启动参数详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
   </entry>
   
   <entry>
     <title>基于GitLab API实现自动化任务</title>
     <link href="http://qiuliang.github.io/tech/2016/05/31/invoke-gitlab-api.html"/>
     <updated>2016-05-31T00:00:00+08:00</updated>
     <id>http://qiuliang.github.io/tech/2016/05/31/invoke-gitlab-api</id>
     <content type="html">&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;之前在团队里&lt;a href=&quot;/tech/2015/10/02/git-nexus-jenkins-ci.html&quot;&gt;基于git、maven、nexus、jenkins搭建适合中小型技术团队的CI平台&lt;/a&gt;，这套系统运行近一年，整体来说还是比较稳定可靠，使用起来也比较方便，基本解决了中小规模团队的CI需求。&lt;/p&gt;

&lt;p&gt;但有个功能一直未完善，使用起来略有不便，就是自动打tag，因我们的build和部署是采用了两套jenkins去实现，而在部署环节的jenkins，是不需要和git交互的，因此也不方便使用类似：&lt;code&gt;git tag&lt;/code&gt; 这样的命令去完成自动打tag的功能。&lt;/p&gt;

&lt;p&gt;因此首先想到的解决方案便是在部署机上通过插件或CURL等方式去调用gitlab的一个api，这样应该能够解决这个问题。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;实现&lt;/h2&gt;

&lt;p&gt;研究了下gitlab的官方文档，发现确实有提供相关API来进行tag的创建，除此之外，还提供了很多其他API，足够你实现很多方便的功能。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;授权&lt;/h3&gt;

&lt;p&gt;调用api都需要使用一个gitlab账号的private token，每个git账号都有不同的private token，查看方法：
登录gitlab，进入Profile Setting — Account，可以看到如下界面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/blog/2016/gitlab-token.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个token可以通过header或者query string方式加到调用请求里。&lt;/p&gt;

&lt;h3 id=&quot;api&quot;&gt;调用API&lt;/h3&gt;

&lt;p&gt;以创建tag为例，其api形式如下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;POST /projects/:id/repository/tags&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;其中参数id可以通过另一接口获取：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;GET /projects&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;传入必须的参数后，gitlab会返回类似于如下的消息，则说明创建tag成功：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;s2&quot;&gt;&amp;quot;name&amp;quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&amp;quot;test&amp;quot;&lt;/span&gt;,
  &lt;span class=&quot;s2&quot;&gt;&amp;quot;message&amp;quot;&lt;/span&gt;: null,
  &lt;span class=&quot;s2&quot;&gt;&amp;quot;commit&amp;quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;id&amp;quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&amp;quot;7cdbfcf12de62dae7fef5ad7eac6b41ab6d04ad9&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;message&amp;quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&amp;quot;Merge branch &amp;#39;weixin&amp;#39; into develop\n&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;parent_ids&amp;quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;s2&quot;&gt;&amp;quot;82e05eb5e681f46810b6e113140bc8577ee0ec64&amp;quot;&lt;/span&gt;,
      &lt;span class=&quot;s2&quot;&gt;&amp;quot;bb2c9646608196eaf4fb5b9b39b5f74bfd9df9b1&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;,
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;authored_date&amp;quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&amp;quot;2016-05-30T18:06:53.000+08:00&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;author_name&amp;quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&amp;quot;test&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;author_email&amp;quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&amp;quot;qiuliang@sohochina.com&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;committed_date&amp;quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&amp;quot;2016-05-30T18:06:53.000+08:00&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;committer_name&amp;quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&amp;quot;test&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;s2&quot;&gt;&amp;quot;committer_email&amp;quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&amp;quot;qiuliang@sohochina.com&amp;quot;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,
  &lt;span class=&quot;s2&quot;&gt;&amp;quot;release&amp;quot;&lt;/span&gt;: null
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;api-1&quot;&gt;部署成功后调用api&lt;/h3&gt;

&lt;p&gt;直接基于jenkins提供的后置脚本功能即可，首先增加全局环境变量配置：GIT_API_TOKEN，其余参数可以为每个project进行配置。&lt;/p&gt;

&lt;p&gt;shell代码如下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;curl -X POST &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
--header &lt;span class=&quot;s2&quot;&gt;&amp;quot;PRIVATE-TOKEN: $GIT_API_TOKEN&amp;quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
--data &lt;span class=&quot;s2&quot;&gt;&amp;quot;tag_name=$Version&amp;amp;ref=$Tag_Ref&amp;amp;release_description=$Tag_Desc&amp;quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
http://code.gitlab.com/api/v3/projects/1/repository/tags&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;完成以上配置，在每次部署成功后都会调用gitlab的api自动创建tag。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>如何对gitlab server进行备份和恢复</title>
     <link href="http://qiuliang.github.io/tech/2016/03/09/gitlab-backup.html"/>
     <updated>2016-03-09T00:00:00+08:00</updated>
     <id>http://qiuliang.github.io/tech/2016/03/09/gitlab-backup</id>
     <content type="html">&lt;blockquote&gt;
  &lt;p&gt;基于gitlab社区版8.5.4&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;创建一个备份&lt;/h2&gt;
&lt;p&gt;gitlab为我们提供了一些方法来创建一个完整的备份，该备份文件是一个压缩包，名称类似于：&lt;code&gt;[Timestamp]_gitlab_backup.tar&lt;/code&gt; 该备份文件包含了所有的DB数据、仓库文件、以及用户上传的一些附件。&lt;/p&gt;

&lt;p&gt;进行一次备份：
sudo gitlab-rake gitlab:backup:create&lt;/p&gt;

&lt;p&gt;最终如果出现如下提示信息，则代表备份成功。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/blog/gitlab-backup.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;备份文件默认保存在如下目录：/var/opt/gitlab/backups，可通过编辑 /var/opt/gitlab/gitlab-rails/etc/gitlab.yml文件的Backup Settings节进行修改。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;备份配置文件&lt;/h3&gt;

&lt;p&gt;db的授权文件和两步验证所需要的密钥信息存储在/etc/gitlab/gitlab-secrets.json文件中，需要单独备份。
gitlab.yml文件也不会包含在上面的备份文件中。&lt;/p&gt;

&lt;h2 id=&quot;gitlab&quot;&gt;恢复gitlab&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;按照官方文档的要求，只能还原备份文件到同一版本的gitlab系统中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;先搭建一个同版本的gitlab到另外一台主机上。（具体安装步骤请参考官方文档）&lt;/p&gt;

&lt;p&gt;环境准备完成后，执行如下命令：
1，拷贝备份文件到新的主机上。
2，停止相关服务
sudo gitlab-ctl stop unicorn
sudo gitlab-ctl stop sidekiq
3，还原数据
gitlab-rake gitlab:backup:restore BACKUP=1457505197
4，启动
sudo gitlab-ctl start&lt;/p&gt;

&lt;p&gt;做完上述操作后，查看系统数据都已经恢复，包括仓库、用户、分组等。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;配置文件和secret文件的恢复需要手工操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-2&quot;&gt;其他实践&lt;/h2&gt;

&lt;h3 id=&quot;git-data&quot;&gt;更改git data目录&lt;/h3&gt;

&lt;p&gt;为了保证数据的安全，一般我们会考虑把git的数据目录放到其他共享存储中，比如：NAS、Virtual SAN等，这时就需要我们修改gitlab中默认的data文件存储路径。&lt;/p&gt;

&lt;p&gt;1，修改gitlab.rb文件中的 git-data-dir参数
2，gitlab-ctl reconfigure
3，gitlab-ctl start&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;自动备份&lt;/h3&gt;

&lt;p&gt;gitlab已经为我们提供了自动备份数据的解决方案，包括cron任务的管理、自动同步到第三方云存储（例如亚马逊AWS），具体参考：http://doc.gitlab.com/ce/raketasks/README.html
当然你也可以用其他方式来备份数据，例如我们的git server位于虚拟化环境，那么可以定期完全备份整个虚机和磁盘，恢复起来也很简单的方便。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>罗辑思维观点解读（一）</title>
     <link href="http://qiuliang.github.io/life/2016/03/02/logic-mind-1.html"/>
     <updated>2016-03-02T00:00:00+08:00</updated>
     <id>http://qiuliang.github.io/life/2016/03/02/logic-mind-1</id>
     <content type="html">&lt;p&gt;&lt;img src=&quot;/images/blog/yinhexi.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以下文字皆源于上班路上听到的罗辑思维节目，节选了一些个人认为对自己有一些启发的观点或知识，整理和思考后分享出来。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;关于末日和对生命的态度&lt;/h2&gt;

&lt;p&gt;世界是否真的存在末日？这个问题相信没有谁能从技术角度回答。但罗辑思维这期主要想要表达的是一种对生命的态度。
生命必然会走向一个终点，可很多现代人似乎忘记了这一点，在有限的生命里，去浪费大把的时光，甚至对生命不再持敬畏之心，如行尸走肉一般。
人之将死，其言也善。这在很多历史人物上得到了印证，可见在“末日”真的到来时，人心终将回归最为纯净的一面，不管之前做了多大的恶。与其这样，不如怀着一颗向死而生的心，认真生活，让生命更有意义和丰富多彩。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;见识决定命运？拒绝逃离北上广&lt;/h2&gt;

&lt;p&gt;所谓见识，只是一个通俗易懂的说法，在现代这个信息爆炸的年代，通过互联网你几乎能了解到人类所有的信息，不管是科技还是经济、政治，这似乎说明，不一定要生活在大城市，你才能拥有“见识”，通过其他渠道你还是能获得这些信息。
但“1/8秒延迟理论”却说明，直接的、面对面的连接，效果一定好于通过电波的连接，只有在这些大量的真实连接的场景下，你才会有更多的机会。
大城市因为各种各样的原因，成为人口最容易聚集的地方，而人口的聚集效应又为创造财富提供好的环境和大量的机会。
因此基于以上简单但有力的结论，推断出至少在未来几十年时间里，一线城市规模还会不断放大，甚至达到上亿级别的超级城市。或许等到人类科技和文明进化到一个更高的台阶的时候，我们才能去过上那种田园诗歌的生活。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;中国未来经济走势&lt;/h2&gt;
&lt;p&gt;这个话题太大，以个人现在的眼界见识，不足以做出一些有价值的总结，但效仿和学习却是可以的。简单来说，前三十年的我们难以想象现在的情景，未来三十年似乎没有理由不变得更好，我们已经走完了基本物质需求经济的时代，新的经济板块需要时代的前瞻者创造出来，这将有着无限多的机会，我们需要时刻准备着。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;互联网时代的隐私&lt;/h2&gt;
&lt;p&gt;关于这个话题，个人在前段时间也有过一些思考并且得出的结论是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在当下的互联网时代，基本没有隐私可言，除非你做一个与世隔绝的隐士。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当然这个没有隐私是相对的，并不是说你的邻居、同事或周围的陌生人对你的一切了如指掌，而是指我们的隐私对于大的互联网公司、银行、国家机构等来说的，他们要获取你的信息非常容易，电商购物记录、家庭/公司地址、朋友圈、银行/保险账户、航空/铁路售票记录、酒店check in记录、遍布各地的摄像头。。，实在是太多了，通过一个身份证号或手机号，就能很容易的勾勒出一个人的大致画像，包括你的年龄、性别、姓名、家庭成员、公司、收入情况等等，想想是不是很可怕？&lt;/p&gt;

&lt;p&gt;其实不然，这恰恰是社会文明进步的一种必然结果，所有的这些其实都是一个人的信用记录，一个人如果打算去做一件违法或者违反道德的事情，就不得不仔细掂量掂量，自己有没有这个能力能把所有的一切都能处理的干干净净？有了不良信用记录之后，他以后还想不想混了，只要他还不打算和社会失去连接，那就不得不去接受这个大信用体系框架带来的惩罚。而这个后果往往是很严重的，虽然现在国内的社会信用评价体系还处在起步阶段，不够健全和完善，但随着时间的推移，终将会成为现实，所以当下我们的生活法则也许要变成：&lt;strong&gt;事无不可对人言&lt;/strong&gt;。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>工作十年回顾：成长与平衡</title>
     <link href="http://qiuliang.github.io/life/2016/01/23/2015_summary.html"/>
     <updated>2016-01-23T00:00:00+08:00</updated>
     <id>http://qiuliang.github.io/life/2016/01/23/2015_summary</id>
     <content type="html">&lt;p&gt;&lt;img src=&quot;/images/blog/xingkong.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;时间总是在我们毫不知情的情况下偷偷溜掉，不禁黯然神伤，在年末的时候能沉下心来花点时间梳理、思考，并能给自己这一年通过文字留下点什么，或许是件然并卵的事情，但起码会得到一点点心理的慰藉，这就够了。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;2015一些重要的数字&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;看完和正在看的书：9本（数字参考于豆瓣我读）&lt;/li&gt;
  &lt;li&gt;发表的博文：5（个人博客）&lt;/li&gt;
  &lt;li&gt;跑步公里数：53Km/11次（咕咚运动）&lt;/li&gt;
  &lt;li&gt;陪伴孩子：基本每个周末都会陪伴&lt;/li&gt;
  &lt;li&gt;陪伴父母：1次&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一年过完，在这些不能带来经济价值，却又很重要的事情上，究竟花了多少时间。
显然除了陪孩子以外，其他数字少得可怜，先留在这里，等未来的某一天看到，并能起到如我所期望那样的一些作用。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;工作10年回顾&lt;/h2&gt;

&lt;p&gt;这是一个有点伤感，又有点让人自豪的事情，工作已10年光景，人生中最热血、宝贵的青春投入到了一个叫“工作”的伟大事业中去，可工作究竟是什么，为什么要工作？在这样的一个阶段，我想停下来仔细思考一番，并以下面的几个问题来回顾总结一下我的第一个十年。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;工作的终极目的是什么？&lt;/h3&gt;

&lt;p&gt;对绝大部分普通人来说，工作和上班其实是画等号的，工作的意义也很简单，通俗一点就是养家糊口。于我而言，前十年的工作也基本是这样一种状态，每天上下班，每月领工资，在工作上的投入程度也跟收获基本成正比，因为有一份工作，让我在亲朋好友眼中看起来是一个正常的人，结婚、生子、买房等等，所有这些“工作”都功不可没，看起来似乎还不错，是吗？&lt;/p&gt;

&lt;p&gt;前几天看了一些有关远程工作社区的分享，感触颇深，其中一个重要的观点就是：上班 ≠ 工作。深以为是，上班其实是一种被动的状态，多少有些无奈的感觉在里面，而工作更多的是一种积极的状态，工作代表着专业、专注，工作的时候你会全情投入，而上班却未必。看似矛盾，却又高度统一，当我感觉自己是在上班的时候，就会去想每天这么做的目的究竟是什么？如果感觉是在工作呢，就会心无旁骛，当完成目标的时候心里盛满了幸福感和满足感。这样的状态是最理想的状态，可人终归有七情六欲、喜怒哀乐，不会总是处于最理想的状态，少量的“上班”而不是“工作”也无可厚非，只是你自己要承担这样的后果罢了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;作为某个社会分工领域专业的人，达成目标，并由此带来内心的愉悦和物质上的收获。这是我在2015年的答案，将来或许会有新的思考。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-3&quot;&gt;如何平衡工作和生活？&lt;/h3&gt;

&lt;p&gt;除了工作，剩下的就是你的生活。你是一个什么样的人，你的生活就是什么样的。但工作却不一定，或多或少都会去扮演职场上的自己。在不同的角色之间切换，保持自律和规律的生活是一个比较有效的平衡方式。周一到周五，固定的时间起床、吃饭、上班、睡觉，周末相对自由随性一些。这样的好处就是当你面对每天的工作时，不会因为一些其他事情而影响到你，工作效率和质量始终是稳定的，周末放松一下，陪陪孩子家人，工作暂时放在一边，也能得到比较好的休息。&lt;/p&gt;

&lt;p&gt;坏处就是平时的生活会变得单调和匆忙，而空闲的时间如果没有用来做一些提升自己的事情，也会有一些失落和焦虑感。解决这些问题的方法自然也是有的，很认同去年朋友圈里转发比较多的一篇文章，大意是生活需要一些&lt;strong&gt;仪式感&lt;/strong&gt;，每个人都应该保持一些认真、庄重的生活态度。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我向来觉得生活是需要一些仪式感的，这跟矫情无关，而是关于你对生活的热爱，对幸福的敏感，乃至有时候它是一种结束，也是一种开始。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个人也要认真的吃饭喝茶，遇到节日纪念日，更是要花点心思庆祝一番，这是我们对生活的一种热爱，在我们每天单调和匆忙的工作中，加入一些生活的情趣和仪式感，就好像我们在吃面条的时候，加一点喜爱的辣酱，回味无穷。&lt;/p&gt;

&lt;p&gt;每个生活在大都市的普通人，都会有一些焦虑感，时时刻刻都在想着挑战自己，做更好的、更成功的自己，可社会就是这样，成功者只是少数，大多数人都如同你我一样平凡，我们成不了马云、马化腾，也成不了罗永浩、罗玉凤，那就还是降低自己的要求和欲望，做一个普通人或是旁观者，也没什么不好。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;慢生活（英语：Downshifting），又称 慢活，是一种社会行为或趋势，其倡导人们摆脱对物质疯狂的迷恋，重过简单的生活，并减少“压力，加班，和可能伴随着它的心理代价”[1]。它强调在日常生活中寻找工作与生活的平衡[2]，并专注于个人价值的实现，和建立人际关系的人生目标，而不是纯粹为了消费而追求经济成功。 –维基百科&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-4&quot;&gt;需要成长为一个什么样的技术人？&lt;/h3&gt;

&lt;p&gt;从事技术工作（软件开发领域）这么长的时间，很庆幸自己还保持着对技术、科技的热情，相信很多同行朋友也是一样的感觉，但技术的发展却又是日新月异，这对我们的学习能力形成巨大的挑战，以下我总结了一些学习新技术的方法或是思考：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一门新语言远没有你想象的困难，一天或是一周也许就够了&lt;/li&gt;
  &lt;li&gt;技术生态圈很重要，学会语言不代表你了解相关生态圈&lt;/li&gt;
  &lt;li&gt;官网文档是最权威的资料，需要最先看&lt;/li&gt;
  &lt;li&gt;github作为全球最大同性（chengxuyuan）交友社区，自然不容错过&lt;/li&gt;
  &lt;li&gt;不要给自己设限，写java的也可以写python，写go的也可以写js，工程师也可以懂产品和体验，相信人的潜力无穷&lt;/li&gt;
  &lt;li&gt;不可替代性是职场重要法则，无关技术，却又依托技术&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然还有很多有益的经验教条，就不一一复述，这个话题如果展开，估计可以写成几个系列，先给自己埋个坑以后再填。&lt;/p&gt;

&lt;p&gt;那究竟要成长为一个什么样的技术人？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在某几个领域有扎实的基本功&lt;/li&gt;
  &lt;li&gt;保持对技术的热情，具备随时挽起袖子上战场的能力和魄力&lt;/li&gt;
  &lt;li&gt;定期的算法/数据结构训练，保持这方面的感觉&lt;/li&gt;
  &lt;li&gt;T字形知识结构&lt;/li&gt;
  &lt;li&gt;除了技术，要关注产品、经济和文化&lt;/li&gt;
  &lt;li&gt;正确的引导新人，乐意看到新人快速成长&lt;/li&gt;
  &lt;li&gt;在团队里具备技术影响力&lt;/li&gt;
  &lt;li&gt;训练你的沟通能力，再进化到现场演讲能力&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虽然自己认识到这么多，可还远没达到这个层次，除了修炼，无他。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这十年我对工作的认知，肤浅也好深刻也罢，都只是自我的一些思考。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-5&quot;&gt;阅读&lt;/h2&gt;

&lt;p&gt;传统意义上的阅读，我还是更偏爱纸质书，即使在现在电子媒体如此发达的今天，2015年看的书不多，寥寥几本，印象比较深刻的如《从0到1》、《万万没想到》、《文明之光》，领域涵盖创业、思维和人文历史，也是个人比较感兴趣的几个方面。&lt;/p&gt;

&lt;p&gt;《万万没想到》算是一本比较另类的书，作者以一个科学家的严谨，用了大量的数据和实验来说明，很多我们习以为常的事情、常识，往往都是错误的，在面对任何一件事情或现象的时候，不要用所谓的常识和固有的经验来禁锢你的思想，也许你是对的，谁又知道呢？&lt;/p&gt;

&lt;p&gt;在下半年的时候为了解决开车途中的无聊，开始大量的听两档脱口秀节目，《晓松奇谈》和《逻辑思维》，虽然都是靠听的，但我认为这也属于阅读的一种，毕竟上下班路上将近3小时的时间里，是可以听很多东西的，这两档节目的内容个人认为还是有一些干货和深度，对我们还是有一些帮助。&lt;/p&gt;

&lt;p&gt;正如逻辑思维2015跨年演讲中提到的，在这个信息大爆炸的时代，看似欣欣向荣、繁花似锦的互联网媒体、自媒体，真正能带给我们有价值的东西，或者说接近于这个世界真相的东西，却是少之又少，或者说是信息噪音干扰太大，我们迷失在一个多维的信息空间，却找不到通往外部的出口。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;通过阅读优质的书本和文章，是我们了解这个复杂世界最重要的方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-6&quot;&gt;停用微信朋友圈的思考&lt;/h2&gt;

&lt;p&gt;从十月底到现在为止，停刷微信朋友圈近三个月，除了确实因为太忙这个理由，我也想试试，生活会有什么变化。
其实是没什么变化。&lt;/p&gt;

&lt;p&gt;失去了什么？&lt;/p&gt;

&lt;p&gt;最近这一个月里，我错过了各位亲朋好友、同学同事、邻居、朋友的朋友、熟悉或不熟悉的人，你们的每一次分享，每一个动态。让人羡慕的旅行、萌宝、美食、美颜照。还错过了各种鸡汤、好笑或不好笑的段子、新闻、谣言、行业干货湿货。丰富多彩、五花八门，有如这冬日里的鸳鸯火锅。然而这些并没有什么用，有价值的信息很少能从朋友圈获取到，但少了跟好友们的互动，还是觉得缺了点什么。&lt;/p&gt;

&lt;p&gt;有失必有得，停刷朋友圈（不是完全不看，是可以集中某个时间段快速、整体的去看）带来的好处也是显而易见的，不会占用我们的一些碎片时间，工作和生活会更加专注，对于一些真正的朋友，面对面或一对一的交流似乎是更有效和更能巩固关系的方式。对于真正想联系的朋友，少点几个赞完全不会影响我们的关系，不是吗？我们自然会通过见面、微信QQ、电话这些方式来建立彼此的联系，这种方式不是更好么。&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;继续前行&lt;/h2&gt;

&lt;p&gt;2016年已经开始，太多的展望并没有什么作用，坚持和踏实依然是我目前认为最简单有效的生活态度和工作方式，做好当下的自己，确保在写完这篇3000多字的总结后，在马上要进入到35岁这个以前觉得很遥远年纪的时候；在面对未来人类进入到更高效科技更发达的时候；在少数精英洞悉这个社会商业法则而大多数人还懵懵懂懂的时候，活得更明白、更滋润一些。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;题图&lt;/h3&gt;

&lt;p&gt;《星夜》文森特.梵高于1889年作于法国。色彩斑斓的颜色对比，流泻、粗狂的画作手法，产生了强烈的星空流动的感觉，展现出非凡的生命力。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>【jenkins实战】利用shell实现远程重启tomcat</title>
     <link href="http://qiuliang.github.io/tech/2015/10/18/jenkins-shell-restart-tomcat.html"/>
     <updated>2015-10-18T00:00:00+08:00</updated>
     <id>http://qiuliang.github.io/tech/2015/10/18/jenkins-shell-restart-tomcat</id>
     <content type="html">&lt;p&gt;在前一篇文章中，介绍了&lt;a href=&quot;http://www.qiuliang.net/tech/2015/10/02/git-nexus-jenkins-ci.html&quot;&gt;如何利用jenkins来搭建一个持续集成平台&lt;/a&gt;，该平台可以帮助我们完成从获取代码、编译、打包、部署等一系列的事情，极大的方便了我们的日常开发工作。&lt;/p&gt;

&lt;p&gt;但在实际使用中发现，之前使用的部署方式，是基于tomcat的热部署，这种方式不是很稳定，尤其在部署次数多了以后，经常出现内存溢出等错误，需要人工干预，这显然不是我们所希望的结果。如果是在一个比较大的研发团队，一般都会有一套自己开发的比较成熟的部署平台，比如我之前所在的团队，专门开发了一套自动化部署平台，简单来说就是在目标server上安装一个agent，利用该agent，可以干很多事情，比如执行前、后置脚本，收集日志、监控server等等。如果在一个创业型的中小规模技术团队，这个事情的成本是比较高的，因此需要另想办法。&lt;/p&gt;

&lt;p&gt;其实解决部署稳定性的问题，一个比较简单的办法就是部署前先停止应用，部署完成后再把应用启动起来。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果你的业务无法忍受短暂的停机，需要考虑部署时的容错，该方案不在本文讨论之列。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;有了大致思路，开始实施就比较简单了，最后总结为如下几个点：&lt;/p&gt;

&lt;h2 id=&quot;jenkins-serverserverssh&quot;&gt;首先需要建立jenkins server和目标server的ssh信任关系&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;ssh-keygen -t &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;rsa&lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;dsa&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
ssh-copy-id -i ~/.ssh/id_rsa.pub user@your_ip_address&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;section&quot;&gt;编写重启脚本&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# author : qiuliang&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# date : 2015-10-15&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# =====deploy变量=====&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 应用程序的context path，如果是根路径，变量值为 ROOT&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;app_context_path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;salesvc
&lt;span class=&quot;c&quot;&gt;# 应用程序端口号&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;app_port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;8082
&lt;span class=&quot;c&quot;&gt;# tomcat目录名称应该满足如下规范，例如：tomcat-端口号&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;app_tomcat_path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/home/work/tomcat-8082
&lt;span class=&quot;c&quot;&gt;# build完成的war包名称&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;war_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;api-1.0-SNAPSHOT.war
&lt;span class=&quot;c&quot;&gt;# war包地址&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;war_url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;http://ci.aaa.com/job/api-sales/api/1.0-SNAPSHOT/api-1.0-SNAPSHOT.war&amp;#39;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# =====deploy变量 end=====&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 进入tomcat应用程序目录&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$app_tomcat_path&lt;/span&gt;/webapps
&lt;span class=&quot;c&quot;&gt;# 备份最近一次的包&lt;/span&gt;
mv &lt;span class=&quot;nv&quot;&gt;$app_context_path&lt;/span&gt;.war &lt;span class=&quot;nv&quot;&gt;$app_context_path&lt;/span&gt;.war.bak
&lt;span class=&quot;c&quot;&gt;# 下载最后一次build的包，该地址需要根据应用具体地址修改&lt;/span&gt;
wget &lt;span class=&quot;nv&quot;&gt;$war_url&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# kill tomcat实例&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;tomcat_pid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;/usr/sbin/lsof -n -P -t -i :&lt;span class=&quot;nv&quot;&gt;$app_port&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; -n &lt;span class=&quot;s2&quot;&gt;&amp;quot;$tomcat_pid&amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;kill&lt;/span&gt; -9 &lt;span class=&quot;nv&quot;&gt;$tomcat_pid&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 删除应用程序目录&lt;/span&gt;
rm -fr &lt;span class=&quot;nv&quot;&gt;$app_tomcat_path&lt;/span&gt;/webapps/&lt;span class=&quot;nv&quot;&gt;$app_context_path&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 重命名context path&lt;/span&gt;
mv &lt;span class=&quot;nv&quot;&gt;$war_name&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$app_context_path&lt;/span&gt;.war
&lt;span class=&quot;c&quot;&gt;# 重新启动tomcat&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;JAVA_HOME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/local/jdk1.7.0_79
&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$app_tomcat_path&lt;/span&gt;/bin/
./startup.sh&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;jenkins-job&quot;&gt;修改jenkins job配置&lt;/h2&gt;

&lt;p&gt;增加build post步骤，选择shell：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;ssh 192.168.220.180 &lt;span class=&quot;s1&quot;&gt;&amp;#39;bash -x -s&amp;#39;&lt;/span&gt; &amp;lt; api/src/main/resources/ci/deploy_test.sh&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;完成上述步骤后，执行job，如果最终显示SUCCESS，则大功告成。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>基于git、maven、nexus、jenkins搭建适合中小型技术团队的CI平台</title>
     <link href="http://qiuliang.github.io/tech/2015/10/02/git-nexus-jenkins-ci.html"/>
     <updated>2015-10-02T00:00:00+08:00</updated>
     <id>http://qiuliang.github.io/tech/2015/10/02/git-nexus-jenkins-ci</id>
     <content type="html">&lt;blockquote&gt;
  &lt;p&gt;在阅读本文前，假设你对git、maven有了一个基本的了解，也包括一些其他的专有名词，如不了解，建议查阅官方资料或直接google。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;为什么要搭建这样一个平台？&lt;/h2&gt;

&lt;p&gt;对于一个稍具规模的研发团队来说，每个角色都各司其职，如果没有一套很好的开发流程和管理手段，那在进行一些相对复杂的项目开发时，因开发流程不规范、管理和沟通效率低下带来的各种问题会层出不穷，大家也会手忙脚乱，不利于项目发展和团队配合。因此搭建一套适合自己团队的持续集成平台，是一个非常重要的事情，至少可以带来如下收益：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;规范的代码分支管理&lt;/li&gt;
  &lt;li&gt;快速的构建&lt;/li&gt;
  &lt;li&gt;尽早的集成&lt;/li&gt;
  &lt;li&gt;提升多项目、多版本的并行能力&lt;/li&gt;
  &lt;li&gt;更可靠的代码和更稳健的应用&lt;/li&gt;
  &lt;li&gt;前后端更彻底的解耦和配合&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ci&quot;&gt;CI系统结构&lt;/h2&gt;

&lt;p&gt;基于团队的实际情况，我们搭建了如下的CI平台，基本都是用开源组件实现，其结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/blog/ci-archetect.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;h5pc-web&quot;&gt;项目开发普通流程（主要是指H5/PC Web）&lt;/h3&gt;

&lt;p&gt;先简单介绍下我们的开发模式：一般将项目分为前后端两个team，前端team负责UI、样式、前端JS逻辑交互、异步渲染等工作；后端team主要负责数据加工、逻辑处理、持久化、分布式cache等工作。&lt;/p&gt;

&lt;p&gt;基于以上分工，一个常规的开发流程一般是这样的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;设计师设计UI&lt;/li&gt;
  &lt;li&gt;前端制作人员制作成HTML原型&lt;/li&gt;
  &lt;li&gt;后端开发人员进行rest接口开发&lt;/li&gt;
  &lt;li&gt;前端人员进行UI交互开发（过程中使用mock进行接口数据模拟，逐步过渡到后端开发人员提供的真实接口）&lt;/li&gt;
  &lt;li&gt;前、后端人员在项目开发中期开始在CI平台进行构建和集成&lt;/li&gt;
  &lt;li&gt;反复debug、持续构建，直至达到RC版本&lt;/li&gt;
  &lt;li&gt;上线、打tag&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用这种开发模式，我认为可以带来如下好处：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;分工清晰、职责明确&lt;/li&gt;
  &lt;li&gt;每个开发人员更加专注于自己的工作&lt;/li&gt;
  &lt;li&gt;系统边界清晰，封装更合理规范
    &lt;ul&gt;
      &lt;li&gt;对于后端开发人员来说，提供的api是给团队内另外的人来使用，因此在封装的时候，包括url、入参、出参等细节考虑更周全，更易于理解；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;前后端的debug更加容易&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;接下来针对该方案，介绍一下几个主要的系统组件的安装和配置方式。&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我们的标准环境一般是基于CentOS 6.5的最小化安装。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;gitlab&quot;&gt;gitlab安装和配置&lt;/h2&gt;

&lt;p&gt;git已经越来越流行，基本上成了互联网研发团队的标配，其灵活的分支模型以及强大的分布式仓库管理能力，对于管理大型项目复杂代码，完全能游刃有余，再搭配上gitlab，图形化的代码管理、简单易用的分支、tag管理，和基本的wiki、issue管理，现在gitlab已经开始出收费的版本了，但即便是免费的社区版本，功能已经是完全够用的。&lt;/p&gt;

&lt;p&gt;另外要强调一下的是gitlab所提供的pull request或者说code review功能，非常的不错，这对提高团队代码质量能起到很大的作用。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;步骤&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;基本按照官网操作步骤即可，以下操作可能会因版本变化而有所差异&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-2&quot;&gt;1. 安装必须的依赖组件&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;sudo yum install curl openssh-server postfix cronie
sudo service postfix start
sudo chkconfig postfix on
sudo lokkit -s http -s ssh&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;gitlab-rpm&quot;&gt;2. 安装gitlab rpm包&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; sudo bash
sudo yum install gitlab-ce
rpm -i gitlab-ce-XXX.rpm&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;gitlab-1&quot;&gt;3. 启动gitlab&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;sudo gitlab-ctl reconfigure&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;host&quot;&gt;4. 访问host地址，使用默认的如下管理员账号可进行配置修改&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;Username: root
Password: 5iveL!fe&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;mavennexus&quot;&gt;maven私服（nexus）安装和配置&lt;/h2&gt;

&lt;p&gt;nexus的安装过程比较简单，从官网下载nexus压缩包后，直接解压到工作目录，执行如下命令即可：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;./bin/nexus console&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;jenkins&quot;&gt;jenkins安装和配置&lt;/h2&gt;

&lt;h3 id=&quot;jenkins-1&quot;&gt;jenkins是什么？&lt;/h3&gt;

&lt;p&gt;简单来说，就是一个能提高开发人员效率的工具，减少一些重复的工作，例如：编译一个软件项目，通过cron去运行一个自动化任务。主要关注点如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;持续build/testing一个软件项目&lt;/li&gt;
  &lt;li&gt;监控外部job的执行情况&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;安装&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;java version “1.7.0_85”
jenkins version : 1.624&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;安装相关包：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;- sudo wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo
- sudo rpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.key
- sudo yum install jenkins&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;启动服务：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;- sudo service jenkins start/stop/restart
- sudo chkconfig jenkins on&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;jenkins web端默认为8080端口，请确认防火墙是否打开。&lt;/p&gt;

&lt;p&gt;如果上面步骤都顺利的话，打开地址：Http://localhost:8080应该可以看到jenkins的管理界面了。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;配置&lt;/h3&gt;

&lt;h4 id=&quot;git&quot;&gt;1. 安装git插件&lt;/h4&gt;

&lt;p&gt;默认没有集成git，需要先安装相关插件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;git plugin&lt;/li&gt;
  &lt;li&gt;git client plugin&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;centosgit&quot;&gt;2. 升级CentOS下的git客户端&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;因为jenkins的git插件需要使用1.7.9以上版本，而CentOS 6.5自带的git是1.7.1版本，需要先升级CentOS下的git。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;rpm –import http://apt.sw.be/RPM-GPG-KEY.dag.txt&lt;/li&gt;
  &lt;li&gt;安装RPMForge源：rpm -i http://pkgs.repoforge.org/rpmforge-release/rpmforge-release-0.5.3-1.el6.rf.x86_64.rpm
        注意选择不同的版本：http://pkgs.repoforge.org/rpmforge-release/&lt;/li&gt;
  &lt;li&gt;查看可用的git模块：yum –enablerepo=rpmforge-extras provides git&lt;/li&gt;
  &lt;li&gt;安装适合当前系统的版本：yum –enablerepo=rpmforge-extras install git-1.7.12.4-1.el6.rfx.x86_64&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;maven&quot;&gt;3. 配置maven&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;下载maven http://maven.apache.org/download.cgi&lt;/li&gt;
  &lt;li&gt;编辑环境变量：vi /etc/profile&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;M2_HOME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/local/apache-maven-3.3.3
&lt;span class=&quot;nv&quot;&gt;PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$PATH&lt;/span&gt;:&lt;span class=&quot;nv&quot;&gt;$JAVA_HOME&lt;/span&gt;/bin:&lt;span class=&quot;nv&quot;&gt;$M2_HOME&lt;/span&gt;/bin
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;环境变量生效：source /etc/profile&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;jenkinsmaven&quot;&gt;3.1 在jenkins管理端配置maven&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/images/blog/jenkins-maven.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在打包的时候，这个地方遇到了一个比较大的坑，主要是我的jenkins server安装在mac下的pd虚机上，如果使用默认的maven中央库的话，会一直报一个错误：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;应该是虚机的网络问题，无法连接到https协议的中央库，后来修改maven使用了oschina的第三方库后解决。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在jenkins执行job时又遇到了文件权限的错误，默认情况下maven生成的包位于如下目录：/var/lib/jenkins/jobs/test/workspace/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;需要修改执行jenkins用户对该目录的写入权限。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;错误：Jenkins needs to know where your Maven is installed.
这个问题的主要原因是全局系统设置中的maven的几个配置不正确，主要配置Maven、Maven Installation几个配置节。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;jdk&quot;&gt;4. 配置JDK&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/blog/jenkins-jdk.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在系统全局设置里面，进行JDK的配置：&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;5. 配置部署插件&lt;/h4&gt;

&lt;p&gt;到插件管理模块中安装：Deploy to container Plugin&lt;/p&gt;

&lt;p&gt;增加自动化部署的配置：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/blog/jenkins-deploy.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;job&quot;&gt;新建一个job&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;选择构建一个maven项目&lt;/li&gt;
  &lt;li&gt;选择需要的jdk版本&lt;/li&gt;
  &lt;li&gt;设置git代码分支地址和身份验证信息&lt;/li&gt;
  &lt;li&gt;选择pom文件的相对路径&lt;/li&gt;
  &lt;li&gt;设置deploy的target&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;完成以上安装和配置工作后，基本上一套标准的CI工作流程就能跑起来了，enjoy！&lt;/p&gt;
</content>
   </entry>
   
 
</feed>

